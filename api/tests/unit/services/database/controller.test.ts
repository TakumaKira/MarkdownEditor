import bcrypt from 'bcrypt'
import * as uuid from 'uuid'
import { v4 as uuidv4 } from 'uuid'
import { fromISOStringToDatetimeString, normalizeDocument } from '../../../../src/services/database'
import { Document, DocumentFromDB } from '../../../../src/models/document'
import { DOCUMENT_CONTENT_LENGTH_LIMIT, DOCUMENT_NAME_LENGTH_LIMIT } from '../../../../src/constants'
import DatabaseController from '../../../../src/services/database/controller'
import getDatabaseController from '../../../../src/services/database'
import { dbClientForTest, waitForShutdown } from '../../../utils'

jest.mock('uuid', () => ({
  __esModule: true,
  ...jest.requireActual('uuid')
}))

let db: DatabaseController

beforeAll(async () => {
  await dbClientForTest.setup()
  db = getDatabaseController(dbClient)
  await addUsers()
})
afterAll(async () => {
  await deleteUsers()
  await dbClientForTest.close()
  await waitForShutdown()
})

type User = { id: number, email: string, password: string }
let mainUser: User
let otherUser: User
const addUsers = async () => {
  mainUser = await generateUser('user1@email.com', 'user1Password')
  otherUser = await generateUser('user2@email.com', 'user2Password')
}
async function generateUser(email: string, password: string): Promise<User> {
  const id = await addUserToDatabase(email, password)
  return { id, email, password }
}
/** @return {number} ID generated by database */
async function addUserToDatabase(email: string, password: string): Promise<number> {
  const salt = await bcrypt.genSalt(10)
  const hashedUser1Password = await bcrypt.hash(password, salt)
  await dbClient.query(sql`
    INSERT INTO users (
      email,
      hashed_password,
      is_activated
    )
    VALUES (
      ${email},
      ${hashedUser1Password},
      true
    );
  `)
  return (await dbClient.query(sql`
    SELECT id
      FROM users
      WHERE email = ${email};
  `))[0].id
}
const deleteUsers = async () => {
  dbClient.query(sql`
    DELETE FROM users;
  `)
}

beforeEach(async () => {
  // Initialize documents table.
  await dbClient.query(sql`
    DELETE FROM documents;
  `)
})
afterEach(async () => {
  return
})

function fromUnixTimestampToISOString(unixTimestamp: number): string {
  return new Date(unixTimestamp * 1000).toISOString()
}

describe('getDocuments', () => {
  test('gets all documents with given id', async () => {
    // Prepare documents.
    const mainUserDocument1: DocumentFromDB = {
      id: uuidv4(),
      user_id: mainUser.id,
      name: "Main user's Document #1",
      content: "This is main user's Document #1.",
      created_at: new Date('2000-01-01T01:00:00.000Z').getTime() / 1000,
      updated_at: new Date('2000-01-01T01:00:00.000Z').getTime() / 1000,
      saved_on_db_at: new Date('2000-01-01T01:00:01.000Z').getTime() / 1000,
      is_deleted: 0
    }
    const mainUserDocument2: DocumentFromDB = {
      id: uuidv4(),
      user_id: mainUser.id,
      name: "Main user's Document #2",
      content: "This is main user's Document #2.",
      created_at: new Date('2000-01-01T02:00:00.000Z').getTime() / 1000,
      updated_at: new Date('2000-01-01T02:00:00.000Z').getTime() / 1000,
      saved_on_db_at: new Date('2000-01-01T02:00:01.000Z').getTime() / 1000,
      is_deleted: 0
    }
    const otherUserDocument1: DocumentFromDB = {
      id: uuidv4(),
      user_id: otherUser.id,
      name: "Other user's Document #1",
      content: "This is other user's Document #1.",
      created_at: new Date('2000-01-02T01:00:00.000Z').getTime() / 1000,
      updated_at: new Date('2000-01-02T01:00:00.000Z').getTime() / 1000,
      saved_on_db_at: new Date('2000-01-02T01:00:01.000Z').getTime() / 1000,
      is_deleted: 0
    }
    // Add to database.
    await dbClient.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${mainUserDocument1.id},
        ${mainUserDocument1.user_id},
        ${mainUserDocument1.name},
        ${mainUserDocument1.content},
        ${fromISOStringToDatetimeString(fromUnixTimestampToISOString(mainUserDocument1.created_at))},
        ${fromISOStringToDatetimeString(fromUnixTimestampToISOString(mainUserDocument1.updated_at))},
        ${fromISOStringToDatetimeString(fromUnixTimestampToISOString(mainUserDocument1.saved_on_db_at))},
        false
      );
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${mainUserDocument2.id},
        ${mainUserDocument2.user_id},
        ${mainUserDocument2.name},
        ${mainUserDocument2.content},
        ${fromISOStringToDatetimeString(fromUnixTimestampToISOString(mainUserDocument2.created_at))},
        ${fromISOStringToDatetimeString(fromUnixTimestampToISOString(mainUserDocument2.updated_at))},
        ${fromISOStringToDatetimeString(fromUnixTimestampToISOString(mainUserDocument2.saved_on_db_at))},
        false
      );
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${otherUserDocument1.id},
        ${otherUserDocument1.user_id},
        ${otherUserDocument1.name},
        ${otherUserDocument1.content},
        ${fromISOStringToDatetimeString(fromUnixTimestampToISOString(otherUserDocument1.created_at))},
        ${fromISOStringToDatetimeString(fromUnixTimestampToISOString(otherUserDocument1.updated_at))},
        ${fromISOStringToDatetimeString(fromUnixTimestampToISOString(otherUserDocument1.saved_on_db_at))},
        false
      );
    `)
    // TEST
    const result = await db.getDocuments([
      mainUserDocument1.id,
      otherUserDocument1.id
    ])
    // RESULT
    expect(result).toEqual([
      mainUserDocument1,
      otherUserDocument1,
    ])
  })
})

describe('updateDocuments', () => {
  test('updates all documents', async () => {
    const document1: Document = {
      id: uuidv4(),
      name: 'Document #1',
      content: 'This is Document #1.',
      createdAt: '2000-01-01T01:00:00.000Z',
      updatedAt: '2000-01-01T01:00:00.000Z',
      savedOnDBAt: '2000-01-01T01:00:01.000Z',
      isDeleted: false
    }
    const document2: Document = {
      id: uuidv4(),
      name: 'Document #2',
      content: 'This is Document #2.',
      createdAt: '2000-01-01T02:00:00.000Z',
      updatedAt: '2000-01-01T02:00:00.000Z',
      savedOnDBAt: '2000-01-01T02:00:01.000Z',
      isDeleted: false
    }
    const documents: Document[] = [
      document1,
      document2,
    ]
    await db.updateDocuments(documents, mainUser.id)
    const result = (await dbClient.query(sql`
      SELECT
        *,
        UNIX_TIMESTAMP(created_at) AS created_at,
        UNIX_TIMESTAMP(updated_at) AS updated_at,
        UNIX_TIMESTAMP(saved_on_db_at) AS saved_on_db_at
      FROM documents
      WHERE user_id = ${mainUser.id}
      ORDER BY updated_at DESC, saved_on_db_at DESC, created_at DESC;
    `)) as DocumentFromDB[]
    expect(result.map(document => normalizeDocument(document))).toEqual([
      document2,
      document1,
    ])
  })

  test('does not update any documents if one of them has duplicated id', async () => {
    const otherUsersDocument: Document = {
      id: uuidv4(),
      name: "Other user's document",
      content: "This is other user's document.",
      createdAt: '2000-01-01T01:00:00.000Z',
      updatedAt: '2000-01-01T01:00:00.000Z',
      savedOnDBAt: '2000-01-01T01:00:01.000Z',
      isDeleted: false
    }
    await dbClient.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${otherUsersDocument.id},
        ${otherUser.id},
        ${otherUsersDocument.name},
        ${otherUsersDocument.content},
        ${fromISOStringToDatetimeString(otherUsersDocument.createdAt)},
        ${fromISOStringToDatetimeString(otherUsersDocument.updatedAt)},
        ${fromISOStringToDatetimeString(otherUsersDocument.savedOnDBAt)},
        ${otherUsersDocument.isDeleted}
      );
    `)
    const documentWithAvailableId: Document = {
      id: uuidv4(),
      name: 'Document #1',
      content: 'This is Document #1.',
      createdAt: '2000-01-01T02:00:00.000Z',
      updatedAt: '2000-01-01T02:00:00.000Z',
      savedOnDBAt: '2000-01-01T02:00:01.000Z',
      isDeleted: false
    }
    const documentWithDuplicatedId: Document = {
      id: otherUsersDocument.id,
      name: 'Document #2',
      content: 'This is Document #2.',
      createdAt: '2000-01-01T03:00:00.000Z',
      updatedAt: '2000-01-01T03:00:00.000Z',
      savedOnDBAt: '2000-01-01T03:00:01.000Z',
      isDeleted: false
    }
    const documents: Document[] = [
      documentWithAvailableId,
      documentWithDuplicatedId,
    ]
    try {
      await db.updateDocuments(documents, mainUser.id)
    } catch (e: any) {
      expect(e.code).toBe('ER_SIGNAL_EXCEPTION')
      expect(e.errno).toBe(1644)
      expect(e.sqlState).toBe('45021')
      expect(e.sqlMessage).toBe("Another user's document is using the same id.")
      expect(e.message).toBe("Another user's document is using the same id.")
    }
    const result = (await dbClient.query(sql`
      SELECT
        *,
        UNIX_TIMESTAMP(created_at) AS created_at,
        UNIX_TIMESTAMP(updated_at) AS updated_at,
        UNIX_TIMESTAMP(saved_on_db_at) AS saved_on_db_at
      FROM documents
      WHERE user_id = ${mainUser.id}
      ORDER BY updated_at DESC, saved_on_db_at DESC, created_at DESC;
    `)) as DocumentFromDB[]
    expect(result.map(document => normalizeDocument(document))).toEqual([])
  })

  test('does not update any documents if one of them has too long name', async () => {
    const alreadySynchedDocument: Document = {
      id: uuidv4(),
      name: 'Already synched document #1',
      content: 'This is already synched document #1.',
      createdAt: '2000-01-01T01:00:00.000Z',
      updatedAt: '2000-01-01T01:00:00.000Z',
      savedOnDBAt: '2000-01-01T01:00:01.000Z',
      isDeleted: false
    }
    await dbClient.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${alreadySynchedDocument.id},
        ${mainUser.id},
        ${alreadySynchedDocument.name},
        ${alreadySynchedDocument.content},
        ${fromISOStringToDatetimeString(alreadySynchedDocument.createdAt)},
        ${fromISOStringToDatetimeString(alreadySynchedDocument.updatedAt)},
        ${fromISOStringToDatetimeString(alreadySynchedDocument.savedOnDBAt)},
        ${alreadySynchedDocument.isDeleted}
      );
    `)
    const documentWithAvailableId: Document = {
      id: uuidv4(),
      name: 'Document #1',
      content: 'This is Document #1.',
      createdAt: '2000-01-01T02:00:00.000Z',
      updatedAt: '2000-01-01T02:00:00.000Z',
      savedOnDBAt: '2000-01-01T02:00:01.000Z',
      isDeleted: false
    }
    const documentWithTooLongName: Document = {
      id: alreadySynchedDocument.id,
      name: 'a'.repeat(DOCUMENT_NAME_LENGTH_LIMIT + 1),
      content: 'This is document with too long name.',
      createdAt: '2000-01-01T03:00:00.000Z',
      updatedAt: '2000-01-01T03:00:00.000Z',
      savedOnDBAt: '2000-01-01T03:00:01.000Z',
      isDeleted: false
    }
    const documents: Document[] = [
      documentWithAvailableId,
      documentWithTooLongName,
    ]
    try {
      await db.updateDocuments(documents, mainUser.id)
    } catch (e: any) {
      expect(e.code).toBe('ER_DATA_TOO_LONG')
      expect(e.errno).toBe(1406)
      expect(e.sqlState).toBe('22001')
      expect(e.sqlMessage).toBe("Data too long for column 'p_name' at row 1")
      expect(e.message).toBe("Data too long for column 'p_name' at row 1")
    }
    const result = (await dbClient.query(sql`
      SELECT
        *,
        UNIX_TIMESTAMP(created_at) AS created_at,
        UNIX_TIMESTAMP(updated_at) AS updated_at,
        UNIX_TIMESTAMP(saved_on_db_at) AS saved_on_db_at
      FROM documents
      WHERE user_id = ${mainUser.id}
      ORDER BY updated_at DESC, saved_on_db_at DESC, created_at DESC;
    `)) as DocumentFromDB[]
    expect(result.map(document => normalizeDocument(document))).toEqual([
      alreadySynchedDocument,
    ])
  })

  test('does not update any documents if one of them has too long content', async () => {
    const alreadySynchedDocument: Document = {
      id: uuidv4(),
      name: 'Already synched document #1',
      content: 'This is already synched document #1.',
      createdAt: '2000-01-01T01:00:00.000Z',
      updatedAt: '2000-01-01T01:00:00.000Z',
      savedOnDBAt: '2000-01-01T01:00:01.000Z',
      isDeleted: false
    }
    await dbClient.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${alreadySynchedDocument.id},
        ${mainUser.id},
        ${alreadySynchedDocument.name},
        ${alreadySynchedDocument.content},
        ${fromISOStringToDatetimeString(alreadySynchedDocument.createdAt)},
        ${fromISOStringToDatetimeString(alreadySynchedDocument.updatedAt)},
        ${fromISOStringToDatetimeString(alreadySynchedDocument.savedOnDBAt)},
        ${alreadySynchedDocument.isDeleted}
      );
    `)
    const documentWithAvailableId: Document = {
      id: uuidv4(),
      name: 'Document #1',
      content: 'This is Document #1.',
      createdAt: '2000-01-01T02:00:00.000Z',
      updatedAt: '2000-01-01T02:00:00.000Z',
      savedOnDBAt: '2000-01-01T02:00:01.000Z',
      isDeleted: false
    }
    const documentWithTooLongContent: Document = {
      id: alreadySynchedDocument.id,
      name: 'Document with too long content',
      content: 'a'.repeat(DOCUMENT_CONTENT_LENGTH_LIMIT + 1),
      createdAt: '2000-01-01T03:00:00.000Z',
      updatedAt: '2000-01-01T03:00:00.000Z',
      savedOnDBAt: '2000-01-01T03:00:01.000Z',
      isDeleted: false
    }
    const documents: Document[] = [
      documentWithAvailableId,
      documentWithTooLongContent,
    ]
    try {
      await db.updateDocuments(documents, mainUser.id)
    } catch (e: any) {
      expect(e.code).toBe('ER_DATA_TOO_LONG')
      expect(e.errno).toBe(1406)
      expect(e.sqlState).toBe('22001')
      expect(e.sqlMessage).toBe("Data too long for column 'p_content' at row 1")
      expect(e.message).toBe("Data too long for column 'p_content' at row 1")
    }
    const result = (await dbClient.query(sql`
      SELECT
        *,
        UNIX_TIMESTAMP(created_at) AS created_at,
        UNIX_TIMESTAMP(updated_at) AS updated_at,
        UNIX_TIMESTAMP(saved_on_db_at) AS saved_on_db_at
      FROM documents
      WHERE user_id = ${mainUser.id}
      ORDER BY updated_at DESC, saved_on_db_at DESC, created_at DESC;
    `)) as DocumentFromDB[]
    expect(result.map(document => normalizeDocument(document))).toEqual([
      alreadySynchedDocument,
    ])
  })
})

describe('getNewSafeId', () => {
  test('gets new id after several try', async () => {
    const TRY = 5
    const idList: string[] = [...new Array(TRY).keys()].map(() => uuidv4())
    let i = 0
    jest.spyOn(uuid, 'v4').mockImplementation(() => idList[i++])
    await dbClient.tx(async _db => {
      for (let j = 0; j < TRY - 1; j++) {
        await _db.query(sql`
          INSERT INTO documents (
            id,
            user_id,
            name,
            content,
            created_at,
            updated_at,
            saved_on_db_at,
            is_deleted
          )
          VALUES (
            ${idList[j]},
            ${mainUser.id},
            ${'Document #' + j},
            ${'This is document #' + j +  '.'},
            ${fromISOStringToDatetimeString('2000-01-01T00:00:0' + j + '.000Z')},
            ${fromISOStringToDatetimeString('2000-01-01T00:00:0' + j + '.000Z')},
            ${fromISOStringToDatetimeString('2000-01-01T00:00:0' + j + '.000Z')},
            false
          );
        `)
      }
    })
    await expect(db.getNewSafeId()).resolves.toBe(idList[TRY - 1])
  })
})
