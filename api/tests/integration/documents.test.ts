import bcrypt from 'bcrypt'
import jwt from 'jsonwebtoken'
import request from 'supertest'
import * as uuid from 'uuid'
import { v4 as uuidv4 } from 'uuid'
import apiServer from '../../src/servers/apiServer/apiServer'
import db, { sql } from '../../src/services/database'
import { API_PATHS, AUTH_TOKEN_KEY, DOCUMENT_CONTENT_LENGTH_LIMIT, DOCUMENT_NAME_LENGTH_LIMIT, DOCUMENT_UPDATED_WS_EVENT } from "../../src/constants"
import { DocumentFromDevice, DocumentFromDB, DocumentsUpdateRequest, DocumentsUpdateResponse, Document } from '../../src/models/document'
import { JWT_SECRET_KEY, WS_PORT } from '../../src/getEnvs'
import { buildGetDocumentQuery, fromISOStringToTimeStamp, getNewSafeId, normalize, updateDocuments } from '../../src/routes/documents'
import { io } from 'socket.io-client'
import { regIsISODateString } from '../../src/middlewares/validator'
import wsServer from '../../src/servers/wsServer/wsServer'

jest.mock('uuid', () => ({
  __esModule: true,
  ...jest.requireActual('uuid')
}))

beforeAll(() => {
  return addUsers()
})
afterAll(() => {
  wsServer.close()
})

type User = { id: number, email: string, password: string, authToken: string }
let mainUser: User
let otherUser: User
const addUsers = async () => {
  mainUser = await generateUser('user1@email.com', 'user1Password')
  otherUser = await generateUser('user2@email.com', 'user2Password')
}
async function generateUser(email: string, password: string): Promise<User> {
  const id = await addUserToDabase(email, password)
  const authToken = jwt.sign(
    {is: 'AuthToken', id, email},
    JWT_SECRET_KEY
  )
  return { id, email, password, authToken }
}
/** @return {number} ID generated by database */
async function addUserToDabase(email: string, password: string): Promise<number> {
  const salt = await bcrypt.genSalt(10)
  const hashedUser1Password = await bcrypt.hash(password, salt)
  await db.query(sql`
    INSERT INTO users (
      email,
      password,
      is_activated
    )
    VALUES (
      ${email},
      ${hashedUser1Password},
      true
    );
  `)
  return (await db.query(sql`
    SELECT id
      FROM users
      WHERE email = ${email};
  `))[0].id
}

beforeEach(() => {
  // Initialize documents table.
  return db.query(sql`
    DELETE FROM documents;
  `)
})
afterEach(() => {
})

// TODO: Update main script to use @database/mysql?

describe(`POST ${API_PATHS.DOCUMENTS.path}`, () => {

  // apiAuthMiddleware tests(check if it guards invalid requests)

  test('returns 401 if no auth token provided', async () => {
    const documentsRequest: DocumentsUpdateRequest = {
      updates: []
    }
    // TESTED REQUEST
    const res = await request(apiServer)
      .post(API_PATHS.DOCUMENTS.path)
      .send(documentsRequest)
    expect(res.status).toBe(401)
    expect(res.body.message).toBe('Access denied. Request does not have valid token.')
  })

  test('returns 401 without updating any documents and emitting no event if no auth token is not valid', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const newDocumentFromDevice: DocumentFromDevice = {
      id: uuidv4(),
      name: 'New Document from Device',
      content: 'This is a new document from the device.',
      createdAt: '2000-01-02T00:00:00.000Z',
      updatedAt: '2000-01-02T00:00:00.000Z',
      savedOnDBAt: null,
      isDeleted: false,
    }
    const newDocumentFromDatabase: Document = {
      id: uuidv4(),
      name: 'New Document from Database',
      content: 'This is a new document from the database.',
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      savedOnDBAt: '2000-01-01T00:00:01.000Z',
      isDeleted: false,
    }
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        newDocumentFromDevice,
      ]
    }
    // Add new document from other device beforehand.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${newDocumentFromDatabase.id},
        ${mainUser.id},
        ${newDocumentFromDatabase.name},
        ${newDocumentFromDatabase.content},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.createdAt)},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.updatedAt)},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.savedOnDBAt)},
        ${newDocumentFromDatabase.isDeleted}
      );
    `)
    // TESTED REQUEST
    const res = await request(apiServer)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: `${mainUser.authToken}1`})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(401)
    expect(res.body.message).toBe('Access denied. Request does not have valid token.')
    // Check database.
    const result = await db.query(sql`
      SELECT id
        FROM documents
        WHERE user_id = ${mainUser.id};
    `)
    expect(result).toEqual([
      {id: newDocumentFromDatabase.id},
    ])
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).not.toBeCalled()
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  test('returns 401 without updating any documents and emitting no event if no auth token is not encoded with right secret', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const newDocumentFromDevice: DocumentFromDevice = {
      id: uuidv4(),
      name: 'New Document from Device',
      content: 'This is a new document from the device.',
      createdAt: '2000-01-02T00:00:00.000Z',
      updatedAt: '2000-01-02T00:00:00.000Z',
      savedOnDBAt: null,
      isDeleted: false,
    }
    const newDocumentFromDatabase: Document = {
      id: uuidv4(),
      name: 'New Document from Database',
      content: 'This is a new document from the database.',
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      savedOnDBAt: '2000-01-01T00:00:01.000Z',
      isDeleted: false,
    }
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        newDocumentFromDevice,
      ]
    }
    // Add new document from other device beforehand.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${newDocumentFromDatabase.id},
        ${mainUser.id},
        ${newDocumentFromDatabase.name},
        ${newDocumentFromDatabase.content},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.createdAt)},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.updatedAt)},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.savedOnDBAt)},
        ${newDocumentFromDatabase.isDeleted}
      );
    `)
    const invalidMainUserAuthToken = jwt.sign(
      {is: 'AuthToken', id: mainUser.id, email: mainUser.email},
      `${JWT_SECRET_KEY}1`
    )
    // TESTED REQUEST
    const res = await request(apiServer)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: invalidMainUserAuthToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(401)
    expect(res.body.message).toBe('Access denied. Request does not have valid token.')
    // Check database.
    const result = await db.query(sql`
      SELECT id
        FROM documents
        WHERE user_id = ${mainUser.id};
    `)
    expect(result).toEqual([
      {id: newDocumentFromDatabase.id},
    ])
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).not.toBeCalled()
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  test('returns 401 without updating any documents and emitting no event if no auth token is not authToken', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const newDocumentFromDevice: DocumentFromDevice = {
      id: uuidv4(),
      name: 'New Document from Device',
      content: 'This is a new document from the device.',
      createdAt: '2000-01-02T00:00:00.000Z',
      updatedAt: '2000-01-02T00:00:00.000Z',
      savedOnDBAt: null,
      isDeleted: false,
    }
    const newDocumentFromDatabase: Document = {
      id: uuidv4(),
      name: 'New Document from Database',
      content: 'This is a new document from the database.',
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      savedOnDBAt: '2000-01-01T00:00:01.000Z',
      isDeleted: false,
    }
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        newDocumentFromDevice,
      ]
    }
    // Add new document from other device beforehand.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${newDocumentFromDatabase.id},
        ${mainUser.id},
        ${newDocumentFromDatabase.name},
        ${newDocumentFromDatabase.content},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.createdAt)},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.updatedAt)},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.savedOnDBAt)},
        ${newDocumentFromDatabase.isDeleted}
      );
    `)
    const mainUserNotAuthToken = jwt.sign(
      {is: 'SignupToken', id: mainUser.id, email: mainUser.email},
      JWT_SECRET_KEY
    )
    // TESTED REQUEST
    const res = await request(apiServer)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUserNotAuthToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(401)
    expect(res.body.message).toBe('Access denied. Request does not have valid token.')
    // Check database.
    const result = await db.query(sql`
      SELECT id
        FROM documents
        WHERE user_id = ${mainUser.id};
    `)
    expect(result).toEqual([
      {id: newDocumentFromDatabase.id},
    ])
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).not.toBeCalled()
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })


  // documentsRequestValidatorMiddleware tests(check if it guards invalid requests)

  test('return 400 without updating any documents and emitting no event if request body is not valid DocumentsRequest', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const invalidNewDocumentFromDevice: DocumentFromDevice = {
      id: uuidv4(),
      name: 'New Document from Device',
      content: 'This is a new document from the device.',
      createdAt: '2000-01-02T00:00:00.000Z',
      updatedAt: '2000-01-02T00:00:00.000',
      savedOnDBAt: null,
      isDeleted: false,
    }
    const newDocumentFromDatabase: Document = {
      id: uuidv4(),
      name: 'New Document from Database',
      content: 'This is a new document from the database.',
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      savedOnDBAt: '2000-01-01T00:00:01.000Z',
      isDeleted: false,
    }
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        invalidNewDocumentFromDevice,
      ]
    }
    // Add new document from other device beforehand.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${newDocumentFromDatabase.id},
        ${mainUser.id},
        ${newDocumentFromDatabase.name},
        ${newDocumentFromDatabase.content},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.createdAt)},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.updatedAt)},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.savedOnDBAt)},
        ${newDocumentFromDatabase.isDeleted}
      );
    `)
    // TESTED REQUEST
    const res = await request(apiServer)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(400)
    expect(res.body.message).toBe("\"updates[0].updatedAt\" with value \"2000-01-02T00:00:00.000\" fails to match the required pattern: /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/")
    // Check database.
    const result = await db.query(sql`
      SELECT id
        FROM documents
        WHERE user_id = ${mainUser.id};
    `)
    expect(result).toEqual([
      {id: newDocumentFromDatabase.id},
    ])
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).not.toBeCalled()
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  test('not update database with too long name and not send the id back', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const newDocumentWithTooLongNameFromDevice: DocumentFromDevice = {
      id: uuidv4(),
      name: 'a'.repeat(DOCUMENT_NAME_LENGTH_LIMIT + 1),
      content: 'This is a new document from the device.',
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      savedOnDBAt: null,
      isDeleted: false,
    }
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        newDocumentWithTooLongNameFromDevice,
      ]
    }
    // TESTED REQUEST
    const res = await request(apiServer)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(400)
    expect(res.body.message).toBe("\"updates[0].name\" length must be less than or equal to 50 characters long")
    // Check database.
    const result = await db.query(sql`
      SELECT id
        FROM documents
        WHERE user_id = ${mainUser.id};
    `)
    expect(result).toEqual([])
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).not.toBeCalled()
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  test('update database with not too long name and sends the id back', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const newDocumentWithNotTooLongNameFromDevice: DocumentFromDevice = {
      id: uuidv4(),
      name: 'a'.repeat(DOCUMENT_NAME_LENGTH_LIMIT),
      content: 'This is a new document from the device.',
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      savedOnDBAt: null,
      isDeleted: false,
    }
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        newDocumentWithNotTooLongNameFromDevice,
      ]
    }
    const documentsUploadResponse: DocumentsUpdateResponse = {
      allDocuments: [
        {
          ...newDocumentWithNotTooLongNameFromDevice,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
      ],
      savedOnDBAt: expect.stringMatching(regIsISODateString),
      updatedIdsAsUnavailable: [],
      duplicatedIdsAsConflicted: [],
    }
    // TESTED REQUEST
    const res = await request(apiServer)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(200)
    expect(res.body).toEqual(documentsUploadResponse)
    // Check database.
    const result = await db.query(sql`
      SELECT id
        FROM documents
        WHERE user_id = ${mainUser.id};
    `)
    expect(result).toEqual([
      {id: newDocumentWithNotTooLongNameFromDevice.id},
    ])
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).toBeCalledWith(expect.stringMatching(regIsISODateString))
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  test('not update database with too long content and not send the id back', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const newDocumentWithTooLongContentFromDevice: DocumentFromDevice = {
      id: uuidv4(),
      name: 'New Document from Device',
      content: 'a'.repeat(DOCUMENT_CONTENT_LENGTH_LIMIT + 1),
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      savedOnDBAt: null,
      isDeleted: false,
    }
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        newDocumentWithTooLongContentFromDevice,
      ]
    }
    // TESTED REQUEST
    const res = await request(apiServer)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(400)
    expect(res.body.message).toBe("\"updates[0].content\" length must be less than or equal to 20000 characters long")
    // Check database.
    const result = await db.query(sql`
      SELECT id
        FROM documents
        WHERE user_id = ${mainUser.id};
    `)
    expect(result).toEqual([])
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).not.toBeCalled()
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  test('updates database with not too long content and sends the id back', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const newDocumentWithNotTooLongContentFromDevice: DocumentFromDevice = {
      id: uuidv4(),
      name: 'New Document from Device',
      content: 'a'.repeat(DOCUMENT_CONTENT_LENGTH_LIMIT),
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      savedOnDBAt: null,
      isDeleted: false,
    }
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        newDocumentWithNotTooLongContentFromDevice,
      ]
    }
    const documentsUploadResponse: DocumentsUpdateResponse = {
      allDocuments: [
        {
          ...newDocumentWithNotTooLongContentFromDevice,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
      ],
      savedOnDBAt: expect.stringMatching(regIsISODateString),
      updatedIdsAsUnavailable: [],
      duplicatedIdsAsConflicted: [],
    }
    // TESTED REQUEST
    const res = await request(apiServer)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(200)
    expect(res.body).toEqual(documentsUploadResponse)
    // Check database.
    const result = await db.query(sql`
      SELECT id
        FROM documents
        WHERE user_id = ${mainUser.id};
    `)
    expect(result).toEqual([
      {id: newDocumentWithNotTooLongContentFromDevice.id},
    ])
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).toBeCalledWith(expect.stringMatching(regIsISODateString))
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  test("inserts on database with new id and returns id change back to device if new document id from device is already registered as another user's document", async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const otherUserDocument: Document = {
      id: uuidv4(),
      name: "Other user's document",
      content: "This is other user's document.",
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      savedOnDBAt: '2000-01-01T00:00:01.000Z',
      isDeleted: false,
    }
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${otherUserDocument.id},
        ${otherUser.id},
        ${otherUserDocument.name},
        ${otherUserDocument.content},
        ${fromISOStringToTimeStamp(otherUserDocument.createdAt)},
        ${fromISOStringToTimeStamp(otherUserDocument.updatedAt)},
        ${fromISOStringToTimeStamp(otherUserDocument.savedOnDBAt)},
        ${otherUserDocument.isDeleted}
      );
    `)
    const mainUsersNewDocument: DocumentFromDevice = {
      id: otherUserDocument.id,
      name: "Main user's new document",
      content: "This is main user's new document.",
      createdAt: '2000-01-02T00:00:00.000Z',
      updatedAt: '2000-01-02T00:00:00.000Z',
      savedOnDBAt: null,
      isDeleted: false,
    }
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        mainUsersNewDocument,
      ]
    }
    const documentsUploadResponse: DocumentsUpdateResponse = {
      allDocuments: [
        {
          ...mainUsersNewDocument,
          id: expect.any(String),
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
      ],
      savedOnDBAt: expect.stringMatching(regIsISODateString),
      updatedIdsAsUnavailable: [
        {
          from: mainUsersNewDocument.id,
          to: expect.any(String)
        },
      ],
      duplicatedIdsAsConflicted: [],
    }
    // TESTED REQUEST
    const res = await request(apiServer)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(200)
    expect(res.body).toEqual(documentsUploadResponse)
    const response: DocumentsUpdateResponse = res.body
    expect(response.allDocuments[0].id).not.toBe(mainUsersNewDocument.id)
    expect(response.updatedIdsAsUnavailable[0].to).toBe(response.allDocuments[0].id)
    // Check database.
    const result = await db.query(sql`
      SELECT id
        FROM documents
        WHERE user_id = ${mainUser.id};
    `)
    expect(result[0].id).not.toEqual([
      {id: mainUsersNewDocument.id},
    ])
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).toBeCalledWith(expect.stringMatching(regIsISODateString))
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  test("inserts on database with new id and returns id change back to device if new document id from device is already registered as the user's another document with different creation time", async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const oldDocument: Document = {
      id: uuidv4(),
      name: "Old document",
      content: "This is old document.",
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      savedOnDBAt: '2000-01-01T00:00:01.000Z',
      isDeleted: false,
    }
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${oldDocument.id},
        ${mainUser.id},
        ${oldDocument.name},
        ${oldDocument.content},
        ${fromISOStringToTimeStamp(oldDocument.createdAt)},
        ${fromISOStringToTimeStamp(oldDocument.updatedAt)},
        ${fromISOStringToTimeStamp(oldDocument.savedOnDBAt)},
        ${oldDocument.isDeleted}
      );
    `)
    const newDocument: DocumentFromDevice = {
      id: oldDocument.id,
      name: "New document",
      content: "This is new document.",
      createdAt: '2000-01-02T00:00:00.000Z',
      updatedAt: '2000-01-02T00:00:00.000Z',
      savedOnDBAt: null,
      isDeleted: false,
    }
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        newDocument,
      ]
    }
    const documentsUploadResponse: DocumentsUpdateResponse = {
      allDocuments: [
        {
          ...newDocument,
          id: expect.any(String),
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
        oldDocument,
      ],
      savedOnDBAt: expect.stringMatching(regIsISODateString),
      updatedIdsAsUnavailable: [
        {
          from: newDocument.id,
          to: expect.any(String)
        },
      ],
      duplicatedIdsAsConflicted: [],
    }
    // TESTED REQUEST
    const res = await request(apiServer)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(200)
    expect(res.body).toEqual(documentsUploadResponse)
    const response: DocumentsUpdateResponse = res.body
    expect(response.allDocuments[0].id).not.toBe(newDocument.id)
    expect(response.updatedIdsAsUnavailable[0].to).toBe(response.allDocuments[0].id)
    // Check database.
    const result = await db.query(sql`
      SELECT id
        FROM documents
        WHERE user_id = ${mainUser.id}
        ORDER BY updated_at DESC, saved_on_db_at DESC, created_at DESC;
    `)
    expect(result[0].id).not.toEqual(newDocument.id)
    expect(result[1].id).toEqual(newDocument.id)
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).toBeCalledWith(expect.stringMatching(regIsISODateString))
    mainUserSocket.close()
  })

  // documentsRouter tests

  test('updates database with updated documents from device and send back updated document id and emit event', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const newDocumentFromDevice: DocumentFromDevice = {
      id: uuidv4(),
      name: 'New Document from Device',
      content: 'This is a new document from the device.',
      createdAt: '2000-01-02T00:00:00.000Z',
      updatedAt: '2000-01-02T00:00:00.000Z',
      savedOnDBAt: null,
      isDeleted: false,
    }
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        newDocumentFromDevice,
      ]
    }
    const documentsUploadResponse: DocumentsUpdateResponse = {
      allDocuments: [
        {
          ...newDocumentFromDevice,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
      ],
      savedOnDBAt: expect.stringMatching(regIsISODateString),
      updatedIdsAsUnavailable: [],
      duplicatedIdsAsConflicted: [],
    }
    // TESTED REQUEST
    const res = await request(apiServer)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(200)
    expect(res.body).toEqual(documentsUploadResponse)
    // Check database.
    const result = await db.query(sql`
      SELECT id
        FROM documents
        WHERE user_id = ${mainUser.id};
    `)
    expect(result).toEqual([
      {id: newDocumentFromDevice.id},
    ])
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).toBeCalledWith(expect.stringMatching(regIsISODateString))
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  test('returns all documents on database', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const oldDocumentFromDatabase: Document = {
      id: uuidv4(),
      name: 'Old Document from Database',
      content: 'This is an old document from the database.',
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      savedOnDBAt: '2000-01-01T00:00:01.000Z',
      isDeleted: false,
    }
    const newDocumentFromDatabase: Document = {
      id: uuidv4(),
      name: 'New Document from Database',
      content: 'This is a new document from the database.',
      createdAt: '2000-01-02T00:00:00.000Z',
      updatedAt: '2000-01-02T00:00:00.000Z',
      savedOnDBAt: '2000-01-02T00:00:01.000Z',
      isDeleted: false,
    }
    // Add documents from other device beforehand.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${oldDocumentFromDatabase.id},
        ${mainUser.id},
        ${oldDocumentFromDatabase.name},
        ${oldDocumentFromDatabase.content},
        ${fromISOStringToTimeStamp(oldDocumentFromDatabase.createdAt)},
        ${fromISOStringToTimeStamp(oldDocumentFromDatabase.updatedAt)},
        ${fromISOStringToTimeStamp(oldDocumentFromDatabase.savedOnDBAt)},
        ${oldDocumentFromDatabase.isDeleted}
      );
    `)
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${newDocumentFromDatabase.id},
        ${mainUser.id},
        ${newDocumentFromDatabase.name},
        ${newDocumentFromDatabase.content},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.createdAt)},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.updatedAt)},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.savedOnDBAt)},
        ${newDocumentFromDatabase.isDeleted}
      );
    `)
    const documentsRequest: DocumentsUpdateRequest = {
      updates: []
    }
    const documentsUploadResponse: DocumentsUpdateResponse = {
      allDocuments: [
        {
          ...newDocumentFromDatabase,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
        {
          ...oldDocumentFromDatabase,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
      ],
      savedOnDBAt: expect.stringMatching(regIsISODateString),
      updatedIdsAsUnavailable: [],
      duplicatedIdsAsConflicted: [],
    }
    // TESTED REQUEST
    const res = await request(apiServer)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(200)
    expect(res.body).toEqual(documentsUploadResponse)
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).not.toBeCalled()
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  test('Updates document on database.', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const oldDocumentFromDatabase: Document = {
      id: uuidv4(),
      name: 'Old Document from Database',
      content: 'This is an old document from the database.',
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      savedOnDBAt: '2000-01-01T00:00:01.000Z',
      isDeleted: false,
    }
    const newDocumentFromDevice: DocumentFromDevice = {
      id: oldDocumentFromDatabase.id,
      name: 'New Document from Database',
      content: 'This is a new document from the database.',
      createdAt: oldDocumentFromDatabase.createdAt,
      updatedAt: '2000-01-02T00:00:00.000Z',
      savedOnDBAt: oldDocumentFromDatabase.savedOnDBAt,
      isDeleted: false,
    }
    // Add documents from other device beforehand.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${oldDocumentFromDatabase.id},
        ${mainUser.id},
        ${oldDocumentFromDatabase.name},
        ${oldDocumentFromDatabase.content},
        ${fromISOStringToTimeStamp(oldDocumentFromDatabase.createdAt)},
        ${fromISOStringToTimeStamp(oldDocumentFromDatabase.updatedAt)},
        ${fromISOStringToTimeStamp(oldDocumentFromDatabase.savedOnDBAt)},
        ${oldDocumentFromDatabase.isDeleted}
      );
    `)
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        newDocumentFromDevice,
      ]
    }
    const documentsUploadResponse: DocumentsUpdateResponse = {
      allDocuments: [
        {
          ...newDocumentFromDevice,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
      ],
      savedOnDBAt: expect.stringMatching(regIsISODateString),
      updatedIdsAsUnavailable: [],
      duplicatedIdsAsConflicted: [],
    }
    // TESTED REQUEST
    const res = await request(apiServer)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(200)
    expect(res.body).toEqual(documentsUploadResponse)
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).toBeCalledWith(expect.stringMatching(regIsISODateString))
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  test('inserts conflicted document with new id on database and returns it back to device with updated on database if document of an id has update both from device and database and emit update to websocket', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const originalDocument: DocumentFromDevice = {
      id: uuidv4(),
      name: 'Original Document',
      content: 'This is an original document.',
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      savedOnDBAt: '2000-01-01T00:00:01.000Z',
      isDeleted: false,
    }
    const updatedOnDatabase: Document = {
      ...originalDocument,
      updatedAt: '2000-01-02T00:00:00.000Z',
      savedOnDBAt: '2000-01-02T00:00:01.000Z',
    }
    const updatedOnDevice: DocumentFromDevice = {
      ...originalDocument,
      updatedAt: '2000-01-03T00:00:00.000Z',
    }
    // Add documents from other device beforehand.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${updatedOnDatabase.id},
        ${mainUser.id},
        ${updatedOnDatabase.name},
        ${updatedOnDatabase.content},
        ${fromISOStringToTimeStamp(updatedOnDatabase.createdAt)},
        ${fromISOStringToTimeStamp(updatedOnDatabase.updatedAt)},
        ${fromISOStringToTimeStamp(updatedOnDatabase.savedOnDBAt)},
        ${updatedOnDatabase.isDeleted}
      );
    `)
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        updatedOnDevice,
      ]
    }
    const copiedOnConflictDuplication: DocumentFromDevice = {
      ...updatedOnDevice,
      id: expect.any(String),
      name: `[Conflicted]: ${updatedOnDevice.name}`,
      updatedAt: expect.stringMatching(regIsISODateString),
      savedOnDBAt: expect.stringMatching(regIsISODateString)
    }
    const documentsUploadResponse: DocumentsUpdateResponse = {
      allDocuments: [
        copiedOnConflictDuplication,
        {
          ...updatedOnDatabase,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
      ],
      savedOnDBAt: expect.stringMatching(regIsISODateString),
      updatedIdsAsUnavailable: [],
      duplicatedIdsAsConflicted: [
        {original: originalDocument.id, duplicated: copiedOnConflictDuplication.id}
      ],
    }
    // TESTED REQUEST
    const res = await request(apiServer)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(200)
    expect(res.body).toEqual(documentsUploadResponse)
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).toBeCalledWith(expect.stringMatching(regIsISODateString))
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  // Test every case at once.
  test("returns updated documents and emit latest updated time to user's websocket with modified document from device and other device being updated to database and conflicted document being duplicated", async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    // Synched before this time.
    const alreadySynched: Document = {
      id: uuidv4(),
      name: 'Already synced on both device and database',
      content: 'This is already synced on both device and database.',
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      savedOnDBAt: '2000-01-01T00:00:01.000Z',
      isDeleted: false
    }
    const toBeDeletedOnDevice: Document = {
      id: uuidv4(),
      name: 'To be deleted on device',
      content: 'This is to be deleted on device.',
      createdAt: '2000-01-01T01:00:00.000Z',
      updatedAt: '2000-01-01T01:00:00.000Z',
      savedOnDBAt: '2000-01-01T01:00:01.000Z',
      isDeleted: false
    }
    const toBeDeletedOnDatabase: Document = {
      id: uuidv4(),
      name: 'To be deleted on database',
      content: 'This is to be deleted on database.',
      createdAt: '2000-01-01T02:00:00.000Z',
      updatedAt: '2000-01-01T02:00:00.000Z',
      savedOnDBAt: '2000-01-01T02:00:01.000Z',
      isDeleted: false
    }
    const toBeConflicted: Document = {
      id: uuidv4(),
      name: 'To be conflicted',
      content: 'This is to be conflicted.',
      createdAt: '2000-01-01T03:00:00.000Z',
      updatedAt: '2000-01-01T03:00:00.000Z',
      savedOnDBAt: '2000-01-01T03:00:01.000Z',
      isDeleted: false
    }
    // Deleted.
    const deletedOnDevice: DocumentFromDevice = {
      id: toBeDeletedOnDevice.id,
      name: null,
      content: null,
      createdAt: toBeDeletedOnDevice.createdAt,
      updatedAt: '2000-01-01T04:00:00.000Z',
      savedOnDBAt: toBeDeletedOnDevice.savedOnDBAt,
      isDeleted: true
    }
    const deletedOnDatabase: Document = {
      id: toBeDeletedOnDatabase.id,
      name: null,
      content: null,
      createdAt: toBeDeletedOnDatabase.createdAt,
      updatedAt: '2000-01-01T05:00:00.000Z',
      savedOnDBAt: toBeDeletedOnDatabase.savedOnDBAt,
      isDeleted: true
    }
    // Modified.
    const conflictedAsBeingModifiedOnDevice: DocumentFromDevice = {
      ...toBeConflicted,
      updatedAt: '2000-01-01T06:00:00.000Z',
    }
    const conflictedAsBeingModifiedOnDatabase: Document = {
      ...toBeConflicted,
      updatedAt: '2000-01-01T07:00:00.000Z',
      savedOnDBAt: '2000-01-01T07:00:01.000Z',
    }
    // Added.
    const addedOnDevice: DocumentFromDevice = {
      id: uuidv4(),
      name: 'Added on device',
      content: 'This is added on device.',
      createdAt: '2000-01-01T08:00:00.000Z',
      updatedAt: '2000-01-01T08:00:00.000Z',
      savedOnDBAt: null,
      isDeleted: false
    }
    const addedOnDatabase: Document = {
      id: uuidv4(),
      name: 'Added on database',
      content: 'This is added on database.',
      createdAt: '2000-01-01T09:00:00.000Z',
      updatedAt: '2000-01-01T09:00:00.000Z',
      savedOnDBAt: '2000-01-01T09:00:01.000Z',
      isDeleted: false
    }
    // Prepare database.
    // Synched before this time.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${alreadySynched.id},
        ${mainUser.id},
        ${alreadySynched.name},
        ${alreadySynched.content},
        ${fromISOStringToTimeStamp(alreadySynched.createdAt)},
        ${fromISOStringToTimeStamp(alreadySynched.updatedAt)},
        ${fromISOStringToTimeStamp(alreadySynched.savedOnDBAt)},
        false
      );
    `)
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${toBeDeletedOnDevice.id},
        ${mainUser.id},
        ${toBeDeletedOnDevice.name},
        ${toBeDeletedOnDevice.content},
        ${fromISOStringToTimeStamp(toBeDeletedOnDevice.createdAt)},
        ${fromISOStringToTimeStamp(toBeDeletedOnDevice.updatedAt)},
        ${fromISOStringToTimeStamp(toBeDeletedOnDevice.savedOnDBAt)},
        false
      );
    `)
    // Deleted.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${deletedOnDatabase.id},
        ${mainUser.id},
        ${deletedOnDatabase.name},
        ${deletedOnDatabase.content},
        ${fromISOStringToTimeStamp(deletedOnDatabase.createdAt)},
        ${fromISOStringToTimeStamp(deletedOnDatabase.updatedAt)},
        ${fromISOStringToTimeStamp(deletedOnDatabase.savedOnDBAt)},
        true
      );
    `)
    // Modified.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${conflictedAsBeingModifiedOnDatabase.id},
        ${mainUser.id},
        ${conflictedAsBeingModifiedOnDatabase.name},
        ${conflictedAsBeingModifiedOnDatabase.content},
        ${fromISOStringToTimeStamp(conflictedAsBeingModifiedOnDatabase.createdAt)},
        ${fromISOStringToTimeStamp(conflictedAsBeingModifiedOnDatabase.updatedAt)},
        ${fromISOStringToTimeStamp(conflictedAsBeingModifiedOnDatabase.savedOnDBAt)},
        false
      );
    `)
    // Added.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${addedOnDatabase.id},
        ${mainUser.id},
        ${addedOnDatabase.name},
        ${addedOnDatabase.content},
        ${fromISOStringToTimeStamp(addedOnDatabase.createdAt)},
        ${fromISOStringToTimeStamp(addedOnDatabase.updatedAt)},
        ${fromISOStringToTimeStamp(addedOnDatabase.savedOnDBAt)},
        false
      );
    `)
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        addedOnDevice,
        deletedOnDevice,
        conflictedAsBeingModifiedOnDevice,
      ]
    }
    const copiedOnConflictDuplication: DocumentFromDevice = {
      ...conflictedAsBeingModifiedOnDevice,
      id: expect.any(String),
      name: `[Conflicted]: ${conflictedAsBeingModifiedOnDevice.name}`,
      updatedAt: expect.stringMatching(regIsISODateString),
    }
    const documentsUploadResponse: DocumentsUpdateResponse = {
      allDocuments: [
        {
          ...copiedOnConflictDuplication,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
        {
          ...addedOnDatabase,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
        {
          ...addedOnDevice,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
        {
          ...conflictedAsBeingModifiedOnDatabase,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
        {
          ...deletedOnDatabase,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
        {
          ...deletedOnDevice,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
        {
          ...alreadySynched,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
      ],
      savedOnDBAt: expect.stringMatching(regIsISODateString),
      updatedIdsAsUnavailable: [],
      duplicatedIdsAsConflicted: [
        {
          original: conflictedAsBeingModifiedOnDevice.id,
          duplicated: copiedOnConflictDuplication.id
        }
      ]
    }
    // TESTED REQUEST
    const res = await request(apiServer)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest)
    expect(res.status).toBe(200)
    expect(res.body).toEqual(documentsUploadResponse)
    expect(copiedOnConflictDuplication.id).not.toBe(conflictedAsBeingModifiedOnDevice.id)
    expect(conflictedAsBeingModifiedOnDevice.updatedAt < copiedOnConflictDuplication.updatedAt).toBe(true)
    const onDatabase = (await db.query(sql`
      SELECT *
        FROM documents
        WHERE user_id = ${mainUser.id}
        ORDER BY updated_at DESC, saved_on_db_at DESC, created_at DESC;
    `)) as DocumentFromDB[]
    expect(onDatabase.map(document => normalize(document))).toEqual(documentsUploadResponse.allDocuments)
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).toBeCalledWith(expect.stringMatching(regIsISODateString))
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  test('returns old update from other device', async () => {
    const newerDocument: DocumentFromDevice = {
      id: uuidv4(),
      name: 'Newer document',
      content: 'This is newer document.',
      createdAt: '2000-01-01T02:00:00.000Z',
      updatedAt: '2000-01-01T02:00:00.000Z',
      savedOnDBAt: null,
      isDeleted: false
    }
    const olderDocument: DocumentFromDevice = {
      id: uuidv4(),
      name: 'Older document',
      content: 'This is older document.',
      createdAt: '2000-01-01T01:00:00.000Z',
      updatedAt: '2000-01-01T01:00:00.000Z',
      savedOnDBAt: null,
      isDeleted: false
    }

    const documentsRequest1FromDeviceA: DocumentsUpdateRequest = {
      updates: [
        newerDocument,
      ]
    }
    const documentsUploadResponse1ForDeviceA: DocumentsUpdateResponse = {
      allDocuments: [
        {
          ...newerDocument,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
      ],
      savedOnDBAt: expect.stringMatching(regIsISODateString),
      updatedIdsAsUnavailable: [],
      duplicatedIdsAsConflicted: []
    }
    const res1ForDeviceA = await request(apiServer)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest1FromDeviceA)
    expect(res1ForDeviceA.body).toEqual(documentsUploadResponse1ForDeviceA)

    const documentsRequestFromDeviceB: DocumentsUpdateRequest = {
      updates: [
        olderDocument,
      ]
    }
    const documentsUploadResponseForDeviceB: DocumentsUpdateResponse = {
      allDocuments: [
        {
          ...newerDocument,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
        {
          ...olderDocument,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
      ],
      savedOnDBAt: expect.stringMatching(regIsISODateString),
      updatedIdsAsUnavailable: [],
      duplicatedIdsAsConflicted: []
    }
    const resForDeviceB = await request(apiServer)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequestFromDeviceB)
    expect(resForDeviceB.body).toEqual(documentsUploadResponseForDeviceB)

    const documentsRequest2FromDeviceA: DocumentsUpdateRequest = {
      updates: []
    }
    const documentsUploadResponse2ForDeviceA: DocumentsUpdateResponse = {
      allDocuments: [
        {
          ...newerDocument,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
        {
          ...olderDocument,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
      ],
      savedOnDBAt: expect.stringMatching(regIsISODateString),
      updatedIdsAsUnavailable: [],
      duplicatedIdsAsConflicted: []
    }
    const res2ForDeviceA = await request(apiServer)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest2FromDeviceA)
    expect(res2ForDeviceA.body).toEqual(documentsUploadResponse2ForDeviceA)
  })
})

describe('buildGetDocumentsQuery', () => {
  test('builds a query which gets all documents with given id', async () => {
    // Prepare documents.
    const mainUserDocument1: DocumentFromDB = {
      id: uuidv4(),
      user_id: mainUser.id,
      name: "Main user's Document #1",
      content: "This is main user's Document #1.",
      created_at: new Date('2000-01-01T01:00:00.000Z'),
      updated_at: new Date('2000-01-01T01:00:00.000Z'),
      saved_on_db_at: new Date('2000-01-01T01:00:01.000Z'),
      is_deleted: 0
    }
    const mainUserDocument2: DocumentFromDB = {
      id: uuidv4(),
      user_id: mainUser.id,
      name: "Main user's Document #2",
      content: "This is main user's Document #2.",
      created_at: new Date('2000-01-01T02:00:00.000Z'),
      updated_at: new Date('2000-01-01T02:00:00.000Z'),
      saved_on_db_at: new Date('2000-01-01T02:00:01.000Z'),
      is_deleted: 0
    }
    const otherUserDocument1: DocumentFromDB = {
      id: uuidv4(),
      user_id: otherUser.id,
      name: "Other user's Document #1",
      content: "This is other user's Document #1.",
      created_at: new Date('2000-01-02T01:00:00.000Z'),
      updated_at: new Date('2000-01-02T01:00:00.000Z'),
      saved_on_db_at: new Date('2000-01-02T01:00:01.000Z'),
      is_deleted: 0
    }
    // Add to database.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${mainUserDocument1.id},
        ${mainUserDocument1.user_id},
        ${mainUserDocument1.name},
        ${mainUserDocument1.content},
        ${fromISOStringToTimeStamp(mainUserDocument1.created_at.toISOString())},
        ${fromISOStringToTimeStamp(mainUserDocument1.updated_at.toISOString())},
        ${fromISOStringToTimeStamp(mainUserDocument1.saved_on_db_at.toISOString())},
        false
      );
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${mainUserDocument2.id},
        ${mainUserDocument2.user_id},
        ${mainUserDocument2.name},
        ${mainUserDocument2.content},
        ${fromISOStringToTimeStamp(mainUserDocument2.created_at.toISOString())},
        ${fromISOStringToTimeStamp(mainUserDocument2.updated_at.toISOString())},
        ${fromISOStringToTimeStamp(mainUserDocument2.saved_on_db_at.toISOString())},
        false
      );
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${otherUserDocument1.id},
        ${otherUserDocument1.user_id},
        ${otherUserDocument1.name},
        ${otherUserDocument1.content},
        ${fromISOStringToTimeStamp(otherUserDocument1.created_at.toISOString())},
        ${fromISOStringToTimeStamp(otherUserDocument1.updated_at.toISOString())},
        ${fromISOStringToTimeStamp(otherUserDocument1.saved_on_db_at.toISOString())},
        false
      );
    `)
    // TEST
    const query = buildGetDocumentQuery(
      mainUserDocument1.id
    )
    const result = (await db.query(query))[0]
    // RESULT
    expect(result).toEqual([
      mainUserDocument1
    ])
  })
})

describe('updateDocuments', () => {
  test('updates all documents', async () => {
    const document1: Document = {
      id: uuidv4(),
      name: 'Document #1',
      content: 'This is Document #1.',
      createdAt: '2000-01-01T01:00:00.000Z',
      updatedAt: '2000-01-01T01:00:00.000Z',
      savedOnDBAt: '2000-01-01T01:00:01.000Z',
      isDeleted: false
    }
    const document2: Document = {
      id: uuidv4(),
      name: 'Document #2',
      content: 'This is Document #2.',
      createdAt: '2000-01-01T02:00:00.000Z',
      updatedAt: '2000-01-01T02:00:00.000Z',
      savedOnDBAt: '2000-01-01T02:00:01.000Z',
      isDeleted: false
    }
    const documents: Document[] = [
      document1,
      document2,
    ]
    await updateDocuments(documents, mainUser.id, db)
    const result = (await db.query(sql`
      SELECT *
        FROM documents
        WHERE user_id = ${mainUser.id}
        ORDER BY updated_at DESC, saved_on_db_at DESC, created_at DESC;
    `)) as DocumentFromDB[]
    expect(result.map(document => normalize(document))).toEqual([
      document2,
      document1,
    ])
  })

  test('does not update any documents if one of them has duplicated id', async () => {
    const otherUsersDocument: Document = {
      id: uuidv4(),
      name: "Other user's document",
      content: "This is other user's document.",
      createdAt: '2000-01-01T01:00:00.000Z',
      updatedAt: '2000-01-01T01:00:00.000Z',
      savedOnDBAt: '2000-01-01T01:00:01.000Z',
      isDeleted: false
    }
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${otherUsersDocument.id},
        ${otherUser.id},
        ${otherUsersDocument.name},
        ${otherUsersDocument.content},
        ${fromISOStringToTimeStamp(otherUsersDocument.createdAt)},
        ${fromISOStringToTimeStamp(otherUsersDocument.updatedAt)},
        ${fromISOStringToTimeStamp(otherUsersDocument.savedOnDBAt)},
        ${otherUsersDocument.isDeleted}
      );
    `)
    const documentWithAvailableId: Document = {
      id: uuidv4(),
      name: 'Document #1',
      content: 'This is Document #1.',
      createdAt: '2000-01-01T02:00:00.000Z',
      updatedAt: '2000-01-01T02:00:00.000Z',
      savedOnDBAt: '2000-01-01T02:00:01.000Z',
      isDeleted: false
    }
    const documentWithDuplicatedId: Document = {
      id: otherUsersDocument.id,
      name: 'Document #2',
      content: 'This is Document #2.',
      createdAt: '2000-01-01T03:00:00.000Z',
      updatedAt: '2000-01-01T03:00:00.000Z',
      savedOnDBAt: '2000-01-01T03:00:01.000Z',
      isDeleted: false
    }
    const documents: Document[] = [
      documentWithAvailableId,
      documentWithDuplicatedId,
    ]
    try {
      await updateDocuments(documents, mainUser.id, db)
    } catch (e: any) {
      expect(e.code).toBe('ER_SIGNAL_EXCEPTION')
      expect(e.errno).toBe(1644)
      expect(e.sqlState).toBe('45021')
      expect(e.sqlMessage).toBe("Another user's document is using the same id.")
      expect(e.message).toBe("Another user's document is using the same id.")
    }
    const result = (await db.query(sql`
      SELECT *
        FROM documents
        WHERE user_id = ${mainUser.id}
        ORDER BY updated_at DESC, saved_on_db_at DESC, created_at DESC;
    `)) as DocumentFromDB[]
    expect(result.map(document => normalize(document))).toEqual([])
  })

  test('does not update any documents if one of them has too long name', async () => {
    const alreadySynchedDocument: Document = {
      id: uuidv4(),
      name: 'Already synched document #1',
      content: 'This is already synched document #1.',
      createdAt: '2000-01-01T01:00:00.000Z',
      updatedAt: '2000-01-01T01:00:00.000Z',
      savedOnDBAt: '2000-01-01T01:00:01.000Z',
      isDeleted: false
    }
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${alreadySynchedDocument.id},
        ${mainUser.id},
        ${alreadySynchedDocument.name},
        ${alreadySynchedDocument.content},
        ${fromISOStringToTimeStamp(alreadySynchedDocument.createdAt)},
        ${fromISOStringToTimeStamp(alreadySynchedDocument.updatedAt)},
        ${fromISOStringToTimeStamp(alreadySynchedDocument.savedOnDBAt)},
        ${alreadySynchedDocument.isDeleted}
      );
    `)
    const documentWithAvailableId: Document = {
      id: uuidv4(),
      name: 'Document #1',
      content: 'This is Document #1.',
      createdAt: '2000-01-01T02:00:00.000Z',
      updatedAt: '2000-01-01T02:00:00.000Z',
      savedOnDBAt: '2000-01-01T02:00:01.000Z',
      isDeleted: false
    }
    const documentWithTooLongName: Document = {
      id: alreadySynchedDocument.id,
      name: 'a'.repeat(DOCUMENT_NAME_LENGTH_LIMIT + 1),
      content: 'This is document with too long name.',
      createdAt: '2000-01-01T03:00:00.000Z',
      updatedAt: '2000-01-01T03:00:00.000Z',
      savedOnDBAt: '2000-01-01T03:00:01.000Z',
      isDeleted: false
    }
    const documents: Document[] = [
      documentWithAvailableId,
      documentWithTooLongName,
    ]
    try {
      await updateDocuments(documents, mainUser.id, db)
    } catch (e: any) {
      expect(e.code).toBe('ER_DATA_TOO_LONG')
      expect(e.errno).toBe(1406)
      expect(e.sqlState).toBe('22001')
      expect(e.sqlMessage).toBe("Data too long for column 'p_name' at row 1")
      expect(e.message).toBe("Data too long for column 'p_name' at row 1")
    }
    const result = (await db.query(sql`
      SELECT *
        FROM documents
        WHERE user_id = ${mainUser.id}
        ORDER BY updated_at DESC, saved_on_db_at DESC, created_at DESC;
    `)) as DocumentFromDB[]
    expect(result.map(document => normalize(document))).toEqual([
      alreadySynchedDocument,
    ])
  })

  test('does not update any documents if one of them has too long content', async () => {
    const alreadySynchedDocument: Document = {
      id: uuidv4(),
      name: 'Already synched document #1',
      content: 'This is already synched document #1.',
      createdAt: '2000-01-01T01:00:00.000Z',
      updatedAt: '2000-01-01T01:00:00.000Z',
      savedOnDBAt: '2000-01-01T01:00:01.000Z',
      isDeleted: false
    }
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        saved_on_db_at,
        is_deleted
      )
      VALUES (
        ${alreadySynchedDocument.id},
        ${mainUser.id},
        ${alreadySynchedDocument.name},
        ${alreadySynchedDocument.content},
        ${fromISOStringToTimeStamp(alreadySynchedDocument.createdAt)},
        ${fromISOStringToTimeStamp(alreadySynchedDocument.updatedAt)},
        ${fromISOStringToTimeStamp(alreadySynchedDocument.savedOnDBAt)},
        ${alreadySynchedDocument.isDeleted}
      );
    `)
    const documentWithAvailableId: Document = {
      id: uuidv4(),
      name: 'Document #1',
      content: 'This is Document #1.',
      createdAt: '2000-01-01T02:00:00.000Z',
      updatedAt: '2000-01-01T02:00:00.000Z',
      savedOnDBAt: '2000-01-01T02:00:01.000Z',
      isDeleted: false
    }
    const documentWithTooLongContent: Document = {
      id: alreadySynchedDocument.id,
      name: 'Document with too long content',
      content: 'a'.repeat(DOCUMENT_CONTENT_LENGTH_LIMIT + 1),
      createdAt: '2000-01-01T03:00:00.000Z',
      updatedAt: '2000-01-01T03:00:00.000Z',
      savedOnDBAt: '2000-01-01T03:00:01.000Z',
      isDeleted: false
    }
    const documents: Document[] = [
      documentWithAvailableId,
      documentWithTooLongContent,
    ]
    try {
      await updateDocuments(documents, mainUser.id, db)
    } catch (e: any) {
      expect(e.code).toBe('ER_DATA_TOO_LONG')
      expect(e.errno).toBe(1406)
      expect(e.sqlState).toBe('22001')
      expect(e.sqlMessage).toBe("Data too long for column 'p_content' at row 1")
      expect(e.message).toBe("Data too long for column 'p_content' at row 1")
    }
    const result = (await db.query(sql`
      SELECT *
        FROM documents
        WHERE user_id = ${mainUser.id}
        ORDER BY updated_at DESC, saved_on_db_at DESC, created_at DESC;
    `)) as DocumentFromDB[]
    expect(result.map(document => normalize(document))).toEqual([
      alreadySynchedDocument,
    ])
  })
})

describe('getNewSafeId', () => {
  test('gets new id after several try', async () => {
    const TRY = 5
    const idList: string[] = [...new Array(TRY).keys()].map(() => uuidv4())
    let i = 0
    jest.spyOn(uuid, 'v4').mockImplementation(() => idList[i++])
    await db.tx(async db => {
      for (let j = 0; j < TRY - 1; j++) {
        await db.query(sql`
          INSERT INTO documents (
            id,
            user_id,
            name,
            content,
            created_at,
            updated_at,
            saved_on_db_at,
            is_deleted
          )
          VALUES (
            ${idList[j]},
            ${mainUser.id},
            ${'Document #' + j},
            ${'This is document #' + j +  '.'},
            ${fromISOStringToTimeStamp('2000-01-01T00:00:0' + j + '.000Z')},
            ${fromISOStringToTimeStamp('2000-01-01T00:00:0' + j + '.000Z')},
            ${fromISOStringToTimeStamp('2000-01-01T00:00:0' + j + '.000Z')},
            false
          );
        `)
      }
    })
    await expect(getNewSafeId()).resolves.toBe(idList[TRY - 1])
  })
})
