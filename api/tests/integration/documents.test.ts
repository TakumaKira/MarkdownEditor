jest.mock('uuid', () => ({
  __esModule: true,
  ...jest.requireActual('uuid')
}))

import bcrypt from 'bcrypt'
import request from 'supertest'
import cookie from 'cookie'
import { io } from 'socket.io-client'
import { v4 as uuidv4 } from 'uuid'
import { fromISOStringToDatetimeString, normalizeDocument } from '../../src/services/database'
import { API_PATHS, DOCUMENT_CONTENT_LENGTH_LIMIT, DOCUMENT_NAME_LENGTH_LIMIT, DOCUMENT_UPDATED_WS_EVENT, SESSION_SID_KEY, HEADER_WS_HANDSHAKE_TOKEN_KEY } from "../../src/constants"
import { DocumentFromDevice, DocumentFromDB, DocumentsUpdateRequest, DocumentsUpdateResponse, Document, DocumentUpdatedWsMessage } from '../../src/models/document'
import { WS_PORT } from '../../src/getEnvs'
import { regIsISODateString } from '../../src/middlewares/validator'
import { apiAppForTest, assertSession, sleep, waitForShutdown } from '../utils'

beforeAll(async () => {
  await apiAppForTest.setup()
  await addUsers()
})
afterAll(async () => {
  await deleteUsers()
  await apiAppForTest.close()
  await waitForShutdown()
})

type User = { id: number, email: string, password: string }
let mainUser: User
let otherUser: User
const addUsers = async () => {
  mainUser = await generateUser('user1@email.com', 'user1Password')
  otherUser = await generateUser('user2@email.com', 'user2Password')
}
async function generateUser(email: string, password: string): Promise<User> {
  const id = await addUserToDatabase(email, password)
  return { id, email, password }
}
/** @return {number} ID generated by database */
async function addUserToDatabase(email: string, password: string): Promise<number> {
  const salt = await bcrypt.genSalt(10)
  const hashedUser1Password = await bcrypt.hash(password, salt)
  await dbClient.query(sql`
    INSERT INTO users (
      email,
      hashed_password,
      is_activated
    )
    VALUES (
      ${email},
      ${hashedUser1Password},
      true
    );
  `)
  return (await dbClient.query(sql`
    SELECT id
      FROM users
      WHERE email = ${email};
  `))[0].id
}
const deleteUsers = async () => {
  dbClient.query(sql`
    DELETE FROM users;
  `)
}

beforeEach(async () => {
  // Initialize documents table.
  await dbClient.query(sql`
    DELETE FROM documents;
  `)
})
afterEach(async () => {
})

const TESTING_WS_SERVER_AP = `ws://localhost:${WS_PORT}`

describe(`POST ${API_PATHS.DOCUMENTS.path}`, () => {

  // apiAuthMiddleware tests(check if it guards invalid requests)

  test('returns 401 if no auth token provided', async () => {
    const documentsRequest: DocumentsUpdateRequest = {
      updates: []
    }
    // TESTED REQUEST
    const res = await request(apiApp)
      .post(API_PATHS.DOCUMENTS.path)
      .send(documentsRequest)
    expect(res.status).toBe(401)
    expect(res.body.message).toBe('Access denied. Request is not authorized.')
  })

  test('returns 401 without updating any documents and emitting no event if session cookie is not valid', async () => {
    const mainUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: mainUser.email, password: mainUser.password })
    const mainUserWsHandshakeToken = mainUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]
    const mainUserSetCookieHeaders: string[] = mainUserResLogin.headers['set-cookie']
    const mainUserCookies = mainUserSetCookieHeaders.map(headerValue => cookie.parse(headerValue))
    const mainUserSessionCookieIndex = mainUserCookies.findIndex((cookie: any) => cookie.hasOwnProperty(SESSION_SID_KEY))
    const mainUserConnectSid: string | undefined = mainUserCookies[mainUserSessionCookieIndex]?.[SESSION_SID_KEY];
    const mainUserValidSessionSid = mainUserConnectSid.match(/s:([^\.]+)/)?.[1]
    const mainUserInvalidCookie: string[] = [mainUserSetCookieHeaders[0].replace(mainUserValidSessionSid!, `${mainUserValidSessionSid}1`)]

    const otherUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: otherUser.email, password: otherUser.password })
    const otherUserWsHandshakeToken = otherUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]

    const mainUserCallback = jest.fn()
    const mainUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: mainUserWsHandshakeToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: otherUserWsHandshakeToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    try {
      const newDocumentFromDevice: DocumentFromDevice = {
        id: uuidv4(),
        name: 'New Document from Device',
        content: 'This is a new document from the device.',
        createdAt: '2000-01-02T00:00:00.000Z',
        updatedAt: '2000-01-02T00:00:00.000Z',
        savedOnDBAt: null,
        isDeleted: false,
      }
      const newDocumentFromDatabase: Document = {
        id: uuidv4(),
        name: 'New Document from Database',
        content: 'This is a new document from the database.',
        createdAt: '2000-01-01T00:00:00.000Z',
        updatedAt: '2000-01-01T00:00:00.000Z',
        savedOnDBAt: '2000-01-01T00:00:01.000Z',
        isDeleted: false,
      }
      const documentsRequest: DocumentsUpdateRequest = {
        updates: [
          newDocumentFromDevice,
        ]
      }
      // Add new document from other device beforehand.
      await dbClient.query(sql`
        INSERT INTO documents (
          id,
          user_id,
          name,
          content,
          created_at,
          updated_at,
          saved_on_db_at,
          is_deleted
        )
        VALUES (
          ${newDocumentFromDatabase.id},
          ${mainUser.id},
          ${newDocumentFromDatabase.name},
          ${newDocumentFromDatabase.content},
          ${fromISOStringToDatetimeString(newDocumentFromDatabase.createdAt)},
          ${fromISOStringToDatetimeString(newDocumentFromDatabase.updatedAt)},
          ${fromISOStringToDatetimeString(newDocumentFromDatabase.savedOnDBAt)},
          ${newDocumentFromDatabase.isDeleted}
        );
      `)
      // TESTED REQUEST
      const res = await request(apiApp)
        .post(API_PATHS.DOCUMENTS.path)
        .set('Cookie', mainUserInvalidCookie)
        .send(documentsRequest)
      // EXPECTED RESPONSE
      expect(res.status).toBe(401)
      expect(res.body.message).toBe('Access denied. Request is not authorized.')
      // Check database.
      const result = await dbClient.query(sql`
        SELECT id
          FROM documents
          WHERE user_id = ${mainUser.id};
      `)
      expect(result).toEqual([
        {id: newDocumentFromDatabase.id},
      ])
      // Check no event on websocket.
      await sleep(100)
      expect(mainUserCallback).not.toBeCalled()
      expect(otherUserCallback).not.toBeCalled()
    } catch (e) {
      throw e
    } finally {
      mainUserSocket.close()
      otherUserSocket.close()
    }
  })

  test('returns 401 without updating any documents and emitting no event if request has session id which has ever been used', async () => {
    const mainUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: mainUser.email, password: mainUser.password })
    const mainUserSetCookieHeaders: string[] = mainUserResLogin.headers['set-cookie']

    const documentsRequest: DocumentsUpdateRequest = {
      updates: []
    }
    const res1 = await request(apiApp)
      .post(API_PATHS.DOCUMENTS.path)
      .set('Cookie', mainUserSetCookieHeaders)
      .send(documentsRequest)
    expect(res1.status).toBe(200)
    // TESTED REQUEST
    const res2 = await request(apiApp)
      .post(API_PATHS.DOCUMENTS.path)
      // Using the same session cookie more than once should result in auth error to prevent Session Fixation attacks.
      .set('Cookie', mainUserSetCookieHeaders)
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res2.status).toBe(401)
    expect(res2.body.message).toBe('Access denied. Request is not authorized.')
  })

  test('reject WebSocket connection if passing old wsHandshakeToken which is gotten from not newest response', async () => {
    const mainUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: mainUser.email, password: mainUser.password })
    const oldMainUserWsHandshakeToken = mainUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]
    const mainUserSetCookieHeaders: string[] = mainUserResLogin.headers['set-cookie']

    const documentsRequest: DocumentsUpdateRequest = {
      updates: []
    }
    const mainUserResForSecondReq = await request(apiApp)
      .post(API_PATHS.DOCUMENTS.path)
      .set('Cookie', mainUserSetCookieHeaders)
      .send(documentsRequest)
    const newMainUserWsHandshakeToken = mainUserResForSecondReq.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]

    const mainUserSocketWithOldToken = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: oldMainUserWsHandshakeToken}})
    const mainUserSocketWithNewToken = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: newMainUserWsHandshakeToken}})
    try {
      mainUserSocketWithOldToken.connect()
      mainUserSocketWithNewToken.connect()
      await sleep(1000)
      expect(mainUserSocketWithOldToken.disconnected).toBe(true)
      expect(mainUserSocketWithNewToken.disconnected).toBe(false)
    } catch (e) {
      throw e
    } finally {
      if (mainUserSocketWithOldToken.connected) {
        mainUserSocketWithOldToken.close()
      }
      if (mainUserSocketWithNewToken.connected) {
        mainUserSocketWithNewToken.close()
      }
    }
  })


  // documentsRequestValidatorMiddleware tests(check if it guards invalid requests)

  test('return 400 without updating any documents and emitting no event if request body is not valid DocumentsRequest', async () => {
    const mainUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: mainUser.email, password: mainUser.password })
    const mainUserWsHandshakeToken = mainUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]
    const mainUserSetCookieHeaders: string[] = mainUserResLogin.headers['set-cookie']

    const otherUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: otherUser.email, password: otherUser.password })
    const otherUserWsHandshakeToken = otherUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]

    const mainUserCallback = jest.fn()
    const mainUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: mainUserWsHandshakeToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: otherUserWsHandshakeToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    try {
      const invalidNewDocumentFromDevice: DocumentFromDevice = {
        id: uuidv4(),
        name: 'New Document from Device',
        content: 'This is a new document from the device.',
        createdAt: '2000-01-02T00:00:00.000Z',
        updatedAt: '2000-01-02T00:00:00.000',
        savedOnDBAt: null,
        isDeleted: false,
      }
      const newDocumentFromDatabase: Document = {
        id: uuidv4(),
        name: 'New Document from Database',
        content: 'This is a new document from the database.',
        createdAt: '2000-01-01T00:00:00.000Z',
        updatedAt: '2000-01-01T00:00:00.000Z',
        savedOnDBAt: '2000-01-01T00:00:01.000Z',
        isDeleted: false,
      }
      const documentsRequest: DocumentsUpdateRequest = {
        updates: [
          invalidNewDocumentFromDevice,
        ]
      }
      // Add new document from other device beforehand.
      await dbClient.query(sql`
        INSERT INTO documents (
          id,
          user_id,
          name,
          content,
          created_at,
          updated_at,
          saved_on_db_at,
          is_deleted
        )
        VALUES (
          ${newDocumentFromDatabase.id},
          ${mainUser.id},
          ${newDocumentFromDatabase.name},
          ${newDocumentFromDatabase.content},
          ${fromISOStringToDatetimeString(newDocumentFromDatabase.createdAt)},
          ${fromISOStringToDatetimeString(newDocumentFromDatabase.updatedAt)},
          ${fromISOStringToDatetimeString(newDocumentFromDatabase.savedOnDBAt)},
          ${newDocumentFromDatabase.isDeleted}
        );
      `)
      // TESTED REQUEST
      const res = await request(apiApp)
        .post(API_PATHS.DOCUMENTS.path)
        .set('Cookie', mainUserSetCookieHeaders)
        .send(documentsRequest)
      // EXPECTED RESPONSE
      expect(res.status).toBe(400)
      expect(res.body.message).toBe("\"updates[0].updatedAt\" with value \"2000-01-02T00:00:00.000\" fails to match the required pattern: /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/")
      // Check database.
      const result = await dbClient.query(sql`
        SELECT id
          FROM documents
          WHERE user_id = ${mainUser.id};
      `)
      expect(result).toEqual([
        {id: newDocumentFromDatabase.id},
      ])
      // Check no event on websocket.
      await sleep(100)
      expect(mainUserCallback).not.toBeCalled()
      expect(otherUserCallback).not.toBeCalled()
    } catch (e) {
      throw e
    } finally {
      mainUserSocket.close()
      otherUserSocket.close()
    }
  })

  test('not update database with too long name and not send the id back', async () => {
    const mainUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: mainUser.email, password: mainUser.password })
    const mainUserWsHandshakeToken = mainUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]
    const mainUserSetCookieHeaders: string[] = mainUserResLogin.headers['set-cookie']

    const otherUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: otherUser.email, password: otherUser.password })
    const otherUserWsHandshakeToken = otherUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]

    const mainUserCallback = jest.fn()
    const mainUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: mainUserWsHandshakeToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: otherUserWsHandshakeToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    try {
      const newDocumentWithTooLongNameFromDevice: DocumentFromDevice = {
        id: uuidv4(),
        name: 'a'.repeat(DOCUMENT_NAME_LENGTH_LIMIT + 1),
        content: 'This is a new document from the device.',
        createdAt: '2000-01-01T00:00:00.000Z',
        updatedAt: '2000-01-01T00:00:00.000Z',
        savedOnDBAt: null,
        isDeleted: false,
      }
      const documentsRequest: DocumentsUpdateRequest = {
        updates: [
          newDocumentWithTooLongNameFromDevice,
        ]
      }
      // TESTED REQUEST
      const res = await request(apiApp)
        .post(API_PATHS.DOCUMENTS.path)
        .set('Cookie', mainUserSetCookieHeaders)
        .send(documentsRequest)
      // EXPECTED RESPONSE
      expect(res.status).toBe(400)
      expect(res.body.message).toBe("\"updates[0].name\" length must be less than or equal to 50 characters long")
      // Check database.
      const result = await dbClient.query(sql`
        SELECT id
          FROM documents
          WHERE user_id = ${mainUser.id};
      `)
      expect(result).toEqual([])
      // Check no event on websocket.
      await sleep(100)
      expect(mainUserCallback).not.toBeCalled()
      expect(otherUserCallback).not.toBeCalled()
    } catch (e) {
      throw e
    } finally {
      mainUserSocket.close()
      otherUserSocket.close()
    }
  })

  test('update database with not too long name and sends the id back', async () => {
    const mainUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: mainUser.email, password: mainUser.password })
    const mainUserWsHandshakeToken = mainUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]
    const mainUserSetCookieHeaders: string[] = mainUserResLogin.headers['set-cookie']

    const otherUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: otherUser.email, password: otherUser.password })
    const otherUserWsHandshakeToken = otherUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]

    const mainUserCallback = jest.fn()
    const mainUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: mainUserWsHandshakeToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: otherUserWsHandshakeToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    try {
      const newDocumentWithNotTooLongNameFromDevice: DocumentFromDevice = {
        id: uuidv4(),
        name: 'a'.repeat(DOCUMENT_NAME_LENGTH_LIMIT),
        content: 'This is a new document from the device.',
        createdAt: '2000-01-01T00:00:00.000Z',
        updatedAt: '2000-01-01T00:00:00.000Z',
        savedOnDBAt: null,
        isDeleted: false,
      }
      const documentsRequest: DocumentsUpdateRequest = {
        updates: [
          newDocumentWithNotTooLongNameFromDevice,
        ]
      }
      const documentsUploadResponse: DocumentsUpdateResponse = {
        allDocuments: [
          {
            ...newDocumentWithNotTooLongNameFromDevice,
            savedOnDBAt: expect.stringMatching(regIsISODateString)
          },
        ],
        savedOnDBAt: expect.stringMatching(regIsISODateString),
        updatedIdsAsUnavailable: [],
        duplicatedIdsAsConflicted: [],
      }
      // TESTED REQUEST
      const res = await request(apiApp)
        .post(API_PATHS.DOCUMENTS.path)
        .set('Cookie', mainUserSetCookieHeaders)
        .send(documentsRequest)
      // EXPECTED RESPONSE
      expect(res.status).toBe(200)
      expect(res.body).toEqual(documentsUploadResponse)
      await assertSession(res, true, mainUser.email)
      // Check database.
      const result = await dbClient.query(sql`
        SELECT id
          FROM documents
          WHERE user_id = ${mainUser.id};
      `)
      expect(result).toEqual([
        {id: newDocumentWithNotTooLongNameFromDevice.id},
      ])
      // Check no event on websocket.
      await sleep(100)
      const message: DocumentUpdatedWsMessage = {savedOnDBAt: expect.stringMatching(regIsISODateString)}
      expect(mainUserCallback).toBeCalledWith(message)
      expect(otherUserCallback).not.toBeCalled()
    } catch (e) {
      throw e
    } finally {
      mainUserSocket.close()
      otherUserSocket.close()
    }
  })

  test('not update database with too long content and not send the id back', async () => {
    const mainUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: mainUser.email, password: mainUser.password })
    const mainUserWsHandshakeToken = mainUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]
    const mainUserSetCookieHeaders: string[] = mainUserResLogin.headers['set-cookie']

    const otherUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: otherUser.email, password: otherUser.password })
    const otherUserWsHandshakeToken = otherUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]

    const mainUserCallback = jest.fn()
    const mainUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: mainUserWsHandshakeToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: otherUserWsHandshakeToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    try {
      const newDocumentWithTooLongContentFromDevice: DocumentFromDevice = {
        id: uuidv4(),
        name: 'New Document from Device',
        content: 'a'.repeat(DOCUMENT_CONTENT_LENGTH_LIMIT + 1),
        createdAt: '2000-01-01T00:00:00.000Z',
        updatedAt: '2000-01-01T00:00:00.000Z',
        savedOnDBAt: null,
        isDeleted: false,
      }
      const documentsRequest: DocumentsUpdateRequest = {
        updates: [
          newDocumentWithTooLongContentFromDevice,
        ]
      }
      // TESTED REQUEST
      const res = await request(apiApp)
        .post(API_PATHS.DOCUMENTS.path)
        .set('Cookie', mainUserSetCookieHeaders)
        .send(documentsRequest)
      // EXPECTED RESPONSE
      expect(res.status).toBe(400)
      expect(res.body.message).toBe("\"updates[0].content\" length must be less than or equal to 20000 characters long")
      // Check database.
      const result = await dbClient.query(sql`
        SELECT id
          FROM documents
          WHERE user_id = ${mainUser.id};
      `)
      expect(result).toEqual([])
      // Check no event on websocket.
      await sleep(100)
      expect(mainUserCallback).not.toBeCalled()
      expect(otherUserCallback).not.toBeCalled()
    } catch (e) {
      throw e
    } finally {
      mainUserSocket.close()
      otherUserSocket.close()
    }
  })

  test('updates database with not too long content and sends the id back', async () => {
    const mainUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: mainUser.email, password: mainUser.password })
    const mainUserWsHandshakeToken = mainUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]
    const mainUserSetCookieHeaders: string[] = mainUserResLogin.headers['set-cookie']

    const otherUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: otherUser.email, password: otherUser.password })
    const otherUserWsHandshakeToken = otherUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]

    const mainUserCallback = jest.fn()
    const mainUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: mainUserWsHandshakeToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: otherUserWsHandshakeToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    try {
      const newDocumentWithNotTooLongContentFromDevice: DocumentFromDevice = {
        id: uuidv4(),
        name: 'New Document from Device',
        content: 'a'.repeat(DOCUMENT_CONTENT_LENGTH_LIMIT),
        createdAt: '2000-01-01T00:00:00.000Z',
        updatedAt: '2000-01-01T00:00:00.000Z',
        savedOnDBAt: null,
        isDeleted: false,
      }
      const documentsRequest: DocumentsUpdateRequest = {
        updates: [
          newDocumentWithNotTooLongContentFromDevice,
        ]
      }
      const documentsUploadResponse: DocumentsUpdateResponse = {
        allDocuments: [
          {
            ...newDocumentWithNotTooLongContentFromDevice,
            savedOnDBAt: expect.stringMatching(regIsISODateString)
          },
        ],
        savedOnDBAt: expect.stringMatching(regIsISODateString),
        updatedIdsAsUnavailable: [],
        duplicatedIdsAsConflicted: [],
      }
      // TESTED REQUEST
      const res = await request(apiApp)
        .post(API_PATHS.DOCUMENTS.path)
        .set('Cookie', mainUserSetCookieHeaders)
        .send(documentsRequest)
      // EXPECTED RESPONSE
      expect(res.status).toBe(200)
      expect(res.body).toEqual(documentsUploadResponse)
      await assertSession(res, true, mainUser.email)
      // Check database.
      const result = await dbClient.query(sql`
        SELECT id
          FROM documents
          WHERE user_id = ${mainUser.id};
      `)
      expect(result).toEqual([
        {id: newDocumentWithNotTooLongContentFromDevice.id},
      ])
      // Check no event on websocket.
      await sleep(100)
      const message: DocumentUpdatedWsMessage = {savedOnDBAt: expect.stringMatching(regIsISODateString)}
      expect(mainUserCallback).toBeCalledWith(message)
      expect(otherUserCallback).not.toBeCalled()
    } catch (e) {
      throw e
    } finally {
      mainUserSocket.close()
      otherUserSocket.close()
    }
  })

  test("inserts on database with new id and returns id change back to device if new document id from device is already registered as another user's document", async () => {
    const mainUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: mainUser.email, password: mainUser.password })
    const mainUserWsHandshakeToken = mainUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]
    const mainUserSetCookieHeaders: string[] = mainUserResLogin.headers['set-cookie']

    const otherUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: otherUser.email, password: otherUser.password })
    const otherUserWsHandshakeToken = otherUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]

    const mainUserCallback = jest.fn()
    const mainUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: mainUserWsHandshakeToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: otherUserWsHandshakeToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    try {
      const otherUserDocument: Document = {
        id: uuidv4(),
        name: "Other user's document",
        content: "This is other user's document.",
        createdAt: '2000-01-01T00:00:00.000Z',
        updatedAt: '2000-01-01T00:00:00.000Z',
        savedOnDBAt: '2000-01-01T00:00:01.000Z',
        isDeleted: false,
      }
      await dbClient.query(sql`
        INSERT INTO documents (
          id,
          user_id,
          name,
          content,
          created_at,
          updated_at,
          saved_on_db_at,
          is_deleted
        )
        VALUES (
          ${otherUserDocument.id},
          ${otherUser.id},
          ${otherUserDocument.name},
          ${otherUserDocument.content},
          ${fromISOStringToDatetimeString(otherUserDocument.createdAt)},
          ${fromISOStringToDatetimeString(otherUserDocument.updatedAt)},
          ${fromISOStringToDatetimeString(otherUserDocument.savedOnDBAt)},
          ${otherUserDocument.isDeleted}
        );
      `)
      const mainUsersNewDocument: DocumentFromDevice = {
        id: otherUserDocument.id,
        name: "Main user's new document",
        content: "This is main user's new document.",
        createdAt: '2000-01-02T00:00:00.000Z',
        updatedAt: '2000-01-02T00:00:00.000Z',
        savedOnDBAt: null,
        isDeleted: false,
      }
      const documentsRequest: DocumentsUpdateRequest = {
        updates: [
          mainUsersNewDocument,
        ]
      }
      const documentsUploadResponse: DocumentsUpdateResponse = {
        allDocuments: [
          {
            ...mainUsersNewDocument,
            id: expect.any(String),
            savedOnDBAt: expect.stringMatching(regIsISODateString)
          },
        ],
        savedOnDBAt: expect.stringMatching(regIsISODateString),
        updatedIdsAsUnavailable: [
          {
            from: mainUsersNewDocument.id,
            to: expect.any(String)
          },
        ],
        duplicatedIdsAsConflicted: [],
      }
      // TESTED REQUEST
      const res = await request(apiApp)
        .post(API_PATHS.DOCUMENTS.path)
        .set('Cookie', mainUserSetCookieHeaders)
        .send(documentsRequest)
      // EXPECTED RESPONSE
      expect(res.status).toBe(200)
      expect(res.body).toEqual(documentsUploadResponse)
      await assertSession(res, true, mainUser.email)
      const response: DocumentsUpdateResponse = res.body
      expect(response.allDocuments[0].id).not.toBe(mainUsersNewDocument.id)
      expect(response.updatedIdsAsUnavailable[0].to).toBe(response.allDocuments[0].id)
      // Check database.
      const result = await dbClient.query(sql`
        SELECT id
          FROM documents
          WHERE user_id = ${mainUser.id};
      `)
      expect(result[0].id).not.toEqual([
        {id: mainUsersNewDocument.id},
      ])
      // Check no event on websocket.
      await sleep(100)
      const message: DocumentUpdatedWsMessage = {savedOnDBAt: expect.stringMatching(regIsISODateString)}
      expect(mainUserCallback).toBeCalledWith(message)
      expect(otherUserCallback).not.toBeCalled()
    } catch (e) {
      throw e
    } finally {
      mainUserSocket.close()
      otherUserSocket.close()
    }
})

  test("inserts on database with new id and returns id change back to device if new document id from device is already registered as the user's another document with different creation time", async () => {
    const mainUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: mainUser.email, password: mainUser.password })
    const mainUserWsHandshakeToken = mainUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]
    const mainUserSetCookieHeaders: string[] = mainUserResLogin.headers['set-cookie']

    const mainUserCallback = jest.fn()
    const mainUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: mainUserWsHandshakeToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    try {
      const oldDocument: Document = {
        id: uuidv4(),
        name: "Old document",
        content: "This is old document.",
        createdAt: '2000-01-01T00:00:00.000Z',
        updatedAt: '2000-01-01T00:00:00.000Z',
        savedOnDBAt: '2000-01-01T00:00:01.000Z',
        isDeleted: false,
      }
      await dbClient.query(sql`
        INSERT INTO documents (
          id,
          user_id,
          name,
          content,
          created_at,
          updated_at,
          saved_on_db_at,
          is_deleted
        )
        VALUES (
          ${oldDocument.id},
          ${mainUser.id},
          ${oldDocument.name},
          ${oldDocument.content},
          ${fromISOStringToDatetimeString(oldDocument.createdAt)},
          ${fromISOStringToDatetimeString(oldDocument.updatedAt)},
          ${fromISOStringToDatetimeString(oldDocument.savedOnDBAt)},
          ${oldDocument.isDeleted}
        );
      `)
      const newDocument: DocumentFromDevice = {
        id: oldDocument.id,
        name: "New document",
        content: "This is new document.",
        createdAt: '2000-01-02T00:00:00.000Z',
        updatedAt: '2000-01-02T00:00:00.000Z',
        savedOnDBAt: null,
        isDeleted: false,
      }
      const documentsRequest: DocumentsUpdateRequest = {
        updates: [
          newDocument,
        ]
      }
      const documentsUploadResponse: DocumentsUpdateResponse = {
        allDocuments: [
          {
            ...newDocument,
            id: expect.any(String),
            savedOnDBAt: expect.stringMatching(regIsISODateString)
          },
          oldDocument,
        ],
        savedOnDBAt: expect.stringMatching(regIsISODateString),
        updatedIdsAsUnavailable: [
          {
            from: newDocument.id,
            to: expect.any(String)
          },
        ],
        duplicatedIdsAsConflicted: [],
      }
      // TESTED REQUEST
      const res = await request(apiApp)
        .post(API_PATHS.DOCUMENTS.path)
        .set('Cookie', mainUserSetCookieHeaders)
        .send(documentsRequest)
      // EXPECTED RESPONSE
      expect(res.status).toBe(200)
      expect(res.body).toEqual(documentsUploadResponse)
      await assertSession(res, true, mainUser.email)
      const response: DocumentsUpdateResponse = res.body
      expect(response.allDocuments[0].id).not.toBe(newDocument.id)
      expect(response.updatedIdsAsUnavailable[0].to).toBe(response.allDocuments[0].id)
      // Check database.
      const result = await dbClient.query(sql`
        SELECT id
          FROM documents
          WHERE user_id = ${mainUser.id}
          ORDER BY updated_at DESC, saved_on_db_at DESC, created_at DESC;
      `)
      expect(result[0].id).not.toEqual(newDocument.id)
      expect(result[1].id).toEqual(newDocument.id)
      // Check no event on websocket.
      await sleep(100)
      const message: DocumentUpdatedWsMessage = {savedOnDBAt: expect.stringMatching(regIsISODateString)}
      expect(mainUserCallback).toBeCalledWith(message)
    } catch (e) {
      throw e
    } finally {
      mainUserSocket.close()
    }
  })

  // documentsRouter tests

  test('updates database with updated documents from device and send back updated document id and emit event', async () => {
    const mainUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: mainUser.email, password: mainUser.password })
    const mainUserWsHandshakeToken = mainUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]
    const mainUserSetCookieHeaders: string[] = mainUserResLogin.headers['set-cookie']

    const otherUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: otherUser.email, password: otherUser.password })
    const otherUserWsHandshakeToken = otherUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]

    const mainUserCallback = jest.fn()
    const mainUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: mainUserWsHandshakeToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: otherUserWsHandshakeToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    try {
      const newDocumentFromDevice: DocumentFromDevice = {
        id: uuidv4(),
        name: 'New Document from Device',
        content: 'This is a new document from the device.',
        createdAt: '2000-01-02T00:00:00.000Z',
        updatedAt: '2000-01-02T00:00:00.000Z',
        savedOnDBAt: null,
        isDeleted: false,
      }
      const documentsRequest: DocumentsUpdateRequest = {
        updates: [
          newDocumentFromDevice,
        ]
      }
      const documentsUploadResponse: DocumentsUpdateResponse = {
        allDocuments: [
          {
            ...newDocumentFromDevice,
            savedOnDBAt: expect.stringMatching(regIsISODateString)
          },
        ],
        savedOnDBAt: expect.stringMatching(regIsISODateString),
        updatedIdsAsUnavailable: [],
        duplicatedIdsAsConflicted: [],
      }
      // TESTED REQUEST
      const res = await request(apiApp)
        .post(API_PATHS.DOCUMENTS.path)
        .set('Cookie', mainUserSetCookieHeaders)
        .send(documentsRequest)
      // EXPECTED RESPONSE
      expect(res.status).toBe(200)
      expect(res.body).toEqual(documentsUploadResponse)
      await assertSession(res, true, mainUser.email)
      // Check database.
      const result = await dbClient.query(sql`
        SELECT id
          FROM documents
          WHERE user_id = ${mainUser.id};
      `)
      expect(result).toEqual([
        {id: newDocumentFromDevice.id},
      ])
      // Check no event on websocket.
      await sleep(100)
      const message: DocumentUpdatedWsMessage = {savedOnDBAt: expect.stringMatching(regIsISODateString)}
      expect(mainUserCallback).toBeCalledWith(message)
      expect(otherUserCallback).not.toBeCalled()
    } catch (e) {
      throw e
    } finally {
      mainUserSocket.close()
      otherUserSocket.close()
    }
  })

  test('returns all documents on database', async () => {
    const mainUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: mainUser.email, password: mainUser.password })
    const mainUserWsHandshakeToken = mainUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]
    const mainUserSetCookieHeaders: string[] = mainUserResLogin.headers['set-cookie']

    const otherUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: otherUser.email, password: otherUser.password })
    const otherUserWsHandshakeToken = otherUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]

    const mainUserCallback = jest.fn()
    const mainUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: mainUserWsHandshakeToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: otherUserWsHandshakeToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    try {
      const oldDocumentFromDatabase: Document = {
        id: uuidv4(),
        name: 'Old Document from Database',
        content: 'This is an old document from the database.',
        createdAt: '2000-01-01T00:00:00.000Z',
        updatedAt: '2000-01-01T00:00:00.000Z',
        savedOnDBAt: '2000-01-01T00:00:01.000Z',
        isDeleted: false,
      }
      const newDocumentFromDatabase: Document = {
        id: uuidv4(),
        name: 'New Document from Database',
        content: 'This is a new document from the database.',
        createdAt: '2000-01-02T00:00:00.000Z',
        updatedAt: '2000-01-02T00:00:00.000Z',
        savedOnDBAt: '2000-01-02T00:00:01.000Z',
        isDeleted: false,
      }
      // Add documents from other device beforehand.
      await dbClient.query(sql`
        INSERT INTO documents (
          id,
          user_id,
          name,
          content,
          created_at,
          updated_at,
          saved_on_db_at,
          is_deleted
        )
        VALUES (
          ${oldDocumentFromDatabase.id},
          ${mainUser.id},
          ${oldDocumentFromDatabase.name},
          ${oldDocumentFromDatabase.content},
          ${fromISOStringToDatetimeString(oldDocumentFromDatabase.createdAt)},
          ${fromISOStringToDatetimeString(oldDocumentFromDatabase.updatedAt)},
          ${fromISOStringToDatetimeString(oldDocumentFromDatabase.savedOnDBAt)},
          ${oldDocumentFromDatabase.isDeleted}
        );
      `)
      await dbClient.query(sql`
        INSERT INTO documents (
          id,
          user_id,
          name,
          content,
          created_at,
          updated_at,
          saved_on_db_at,
          is_deleted
        )
        VALUES (
          ${newDocumentFromDatabase.id},
          ${mainUser.id},
          ${newDocumentFromDatabase.name},
          ${newDocumentFromDatabase.content},
          ${fromISOStringToDatetimeString(newDocumentFromDatabase.createdAt)},
          ${fromISOStringToDatetimeString(newDocumentFromDatabase.updatedAt)},
          ${fromISOStringToDatetimeString(newDocumentFromDatabase.savedOnDBAt)},
          ${newDocumentFromDatabase.isDeleted}
        );
      `)
      const documentsRequest: DocumentsUpdateRequest = {
        updates: []
      }
      const documentsUploadResponse: DocumentsUpdateResponse = {
        allDocuments: [
          {
            ...newDocumentFromDatabase,
            savedOnDBAt: expect.stringMatching(regIsISODateString)
          },
          {
            ...oldDocumentFromDatabase,
            savedOnDBAt: expect.stringMatching(regIsISODateString)
          },
        ],
        savedOnDBAt: expect.stringMatching(regIsISODateString),
        updatedIdsAsUnavailable: [],
        duplicatedIdsAsConflicted: [],
      }
      // TESTED REQUEST
      const res = await request(apiApp)
        .post(API_PATHS.DOCUMENTS.path)
        .set('Cookie', mainUserSetCookieHeaders)
        .send(documentsRequest)
      // EXPECTED RESPONSE
      expect(res.status).toBe(200)
      expect(res.body).toEqual(documentsUploadResponse)
      await assertSession(res, true, mainUser.email)
      // Check no event on websocket.
      await sleep(100)
      expect(mainUserCallback).not.toBeCalled()
      expect(otherUserCallback).not.toBeCalled()
    } catch (e) {
      throw e
    } finally {
      mainUserSocket.close()
      otherUserSocket.close()
    }
  })

  test('Updates document on database.', async () => {
    const mainUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: mainUser.email, password: mainUser.password })
    const mainUserWsHandshakeToken = mainUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]
    const mainUserSetCookieHeaders: string[] = mainUserResLogin.headers['set-cookie']

    const otherUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: otherUser.email, password: otherUser.password })
    const otherUserWsHandshakeToken = otherUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]

    const mainUserCallback = jest.fn()
    const mainUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: mainUserWsHandshakeToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: otherUserWsHandshakeToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    try {
      const oldDocumentFromDatabase: Document = {
        id: uuidv4(),
        name: 'Old Document from Database',
        content: 'This is an old document from the database.',
        createdAt: '2000-01-01T00:00:00.000Z',
        updatedAt: '2000-01-01T00:00:00.000Z',
        savedOnDBAt: '2000-01-01T00:00:01.000Z',
        isDeleted: false,
      }
      const newDocumentFromDevice: DocumentFromDevice = {
        id: oldDocumentFromDatabase.id,
        name: 'New Document from Database',
        content: 'This is a new document from the database.',
        createdAt: oldDocumentFromDatabase.createdAt,
        updatedAt: '2000-01-02T00:00:00.000Z',
        savedOnDBAt: oldDocumentFromDatabase.savedOnDBAt,
        isDeleted: false,
      }
      // Add documents from other device beforehand.
      await dbClient.query(sql`
        INSERT INTO documents (
          id,
          user_id,
          name,
          content,
          created_at,
          updated_at,
          saved_on_db_at,
          is_deleted
        )
        VALUES (
          ${oldDocumentFromDatabase.id},
          ${mainUser.id},
          ${oldDocumentFromDatabase.name},
          ${oldDocumentFromDatabase.content},
          ${fromISOStringToDatetimeString(oldDocumentFromDatabase.createdAt)},
          ${fromISOStringToDatetimeString(oldDocumentFromDatabase.updatedAt)},
          ${fromISOStringToDatetimeString(oldDocumentFromDatabase.savedOnDBAt)},
          ${oldDocumentFromDatabase.isDeleted}
        );
      `)
      const documentsRequest: DocumentsUpdateRequest = {
        updates: [
          newDocumentFromDevice,
        ]
      }
      const documentsUploadResponse: DocumentsUpdateResponse = {
        allDocuments: [
          {
            ...newDocumentFromDevice,
            savedOnDBAt: expect.stringMatching(regIsISODateString)
          },
        ],
        savedOnDBAt: expect.stringMatching(regIsISODateString),
        updatedIdsAsUnavailable: [],
        duplicatedIdsAsConflicted: [],
      }
      // TESTED REQUEST
      const res = await request(apiApp)
        .post(API_PATHS.DOCUMENTS.path)
        .set('Cookie', mainUserSetCookieHeaders)
        .send(documentsRequest)
      // EXPECTED RESPONSE
      expect(res.status).toBe(200)
      expect(res.body).toEqual(documentsUploadResponse)
      await assertSession(res, true, mainUser.email)
      // Check no event on websocket.
      await sleep(100)
      const message: DocumentUpdatedWsMessage = {savedOnDBAt: expect.stringMatching(regIsISODateString)}
      expect(mainUserCallback).toBeCalledWith(message)
      expect(otherUserCallback).not.toBeCalled()
    } catch (e) {
      throw e
    } finally {
      mainUserSocket.close()
      otherUserSocket.close()
    }
  })

  test('inserts conflicted document with new id on database and returns it back to device with updated on database if document of an id has update both from device and database and emit update to websocket', async () => {
    const mainUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: mainUser.email, password: mainUser.password })
    const mainUserWsHandshakeToken = mainUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]
    const mainUserSetCookieHeaders: string[] = mainUserResLogin.headers['set-cookie']

    const otherUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: otherUser.email, password: otherUser.password })
    const otherUserWsHandshakeToken = otherUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]

    const mainUserCallback = jest.fn()
    const mainUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: mainUserWsHandshakeToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: otherUserWsHandshakeToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    try {
      const originalDocument: DocumentFromDevice = {
        id: uuidv4(),
        name: 'Original Document',
        content: 'This is an original document.',
        createdAt: '2000-01-01T00:00:00.000Z',
        updatedAt: '2000-01-01T00:00:00.000Z',
        savedOnDBAt: '2000-01-01T00:00:01.000Z',
        isDeleted: false,
      }
      const updatedOnDatabase: Document = {
        ...originalDocument,
        updatedAt: '2000-01-02T00:00:00.000Z',
        savedOnDBAt: '2000-01-02T00:00:01.000Z',
      }
      const updatedOnDevice: DocumentFromDevice = {
        ...originalDocument,
        updatedAt: '2000-01-03T00:00:00.000Z',
      }
      // Add documents from other device beforehand.
      await dbClient.query(sql`
        INSERT INTO documents (
          id,
          user_id,
          name,
          content,
          created_at,
          updated_at,
          saved_on_db_at,
          is_deleted
        )
        VALUES (
          ${updatedOnDatabase.id},
          ${mainUser.id},
          ${updatedOnDatabase.name},
          ${updatedOnDatabase.content},
          ${fromISOStringToDatetimeString(updatedOnDatabase.createdAt)},
          ${fromISOStringToDatetimeString(updatedOnDatabase.updatedAt)},
          ${fromISOStringToDatetimeString(updatedOnDatabase.savedOnDBAt)},
          ${updatedOnDatabase.isDeleted}
        );
      `)
      const documentsRequest: DocumentsUpdateRequest = {
        updates: [
          updatedOnDevice,
        ]
      }
      const copiedOnConflictDuplication: DocumentFromDevice = {
        ...updatedOnDevice,
        id: expect.any(String),
        name: `[Conflicted]: ${updatedOnDevice.name}`,
        updatedAt: expect.stringMatching(regIsISODateString),
        savedOnDBAt: expect.stringMatching(regIsISODateString)
      }
      const documentsUploadResponse: DocumentsUpdateResponse = {
        allDocuments: [
          copiedOnConflictDuplication,
          {
            ...updatedOnDatabase,
            savedOnDBAt: expect.stringMatching(regIsISODateString)
          },
        ],
        savedOnDBAt: expect.stringMatching(regIsISODateString),
        updatedIdsAsUnavailable: [],
        duplicatedIdsAsConflicted: [
          {original: originalDocument.id, duplicated: copiedOnConflictDuplication.id}
        ],
      }
      // TESTED REQUEST
      const res = await request(apiApp)
        .post(API_PATHS.DOCUMENTS.path)
        .set('Cookie', mainUserSetCookieHeaders)
        .send(documentsRequest)
      // EXPECTED RESPONSE
      expect(res.status).toBe(200)
      expect(res.body).toEqual(documentsUploadResponse)
      await assertSession(res, true, mainUser.email)
      // Check no event on websocket.
      await sleep(100)
      const message: DocumentUpdatedWsMessage = {savedOnDBAt: expect.stringMatching(regIsISODateString)}
      expect(mainUserCallback).toBeCalledWith(message)
      expect(otherUserCallback).not.toBeCalled()
    } catch (e) {
      throw e
    } finally {
      mainUserSocket.close()
      otherUserSocket.close()
    }
  })

  // Test every case at once.
  test("returns updated documents and emit latest updated time to user's websocket with modified document from device and other device being updated to database and conflicted document being duplicated", async () => {
    const mainUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: mainUser.email, password: mainUser.password })
    const mainUserWsHandshakeToken = mainUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]
    const mainUserSetCookieHeaders: string[] = mainUserResLogin.headers['set-cookie']

    const otherUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: otherUser.email, password: otherUser.password })
    const otherUserWsHandshakeToken = otherUserResLogin.headers[HEADER_WS_HANDSHAKE_TOKEN_KEY]

    const mainUserCallback = jest.fn()
    const mainUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: mainUserWsHandshakeToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(TESTING_WS_SERVER_AP, {autoConnect: false, auth: {wsHandshakeToken: otherUserWsHandshakeToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    try {
      // Synched before this time.
      const alreadySynched: Document = {
        id: uuidv4(),
        name: 'Already synced on both device and database',
        content: 'This is already synced on both device and database.',
        createdAt: '2000-01-01T00:00:00.000Z',
        updatedAt: '2000-01-01T00:00:00.000Z',
        savedOnDBAt: '2000-01-01T00:00:01.000Z',
        isDeleted: false
      }
      const toBeDeletedOnDevice: Document = {
        id: uuidv4(),
        name: 'To be deleted on device',
        content: 'This is to be deleted on device.',
        createdAt: '2000-01-01T01:00:00.000Z',
        updatedAt: '2000-01-01T01:00:00.000Z',
        savedOnDBAt: '2000-01-01T01:00:01.000Z',
        isDeleted: false
      }
      const toBeDeletedOnDatabase: Document = {
        id: uuidv4(),
        name: 'To be deleted on database',
        content: 'This is to be deleted on database.',
        createdAt: '2000-01-01T02:00:00.000Z',
        updatedAt: '2000-01-01T02:00:00.000Z',
        savedOnDBAt: '2000-01-01T02:00:01.000Z',
        isDeleted: false
      }
      const toBeConflicted: Document = {
        id: uuidv4(),
        name: 'To be conflicted',
        content: 'This is to be conflicted.',
        createdAt: '2000-01-01T03:00:00.000Z',
        updatedAt: '2000-01-01T03:00:00.000Z',
        savedOnDBAt: '2000-01-01T03:00:01.000Z',
        isDeleted: false
      }
      // Deleted.
      const deletedOnDevice: DocumentFromDevice = {
        id: toBeDeletedOnDevice.id,
        name: null,
        content: null,
        createdAt: toBeDeletedOnDevice.createdAt,
        updatedAt: '2000-01-01T04:00:00.000Z',
        savedOnDBAt: toBeDeletedOnDevice.savedOnDBAt,
        isDeleted: true
      }
      const deletedOnDatabase: Document = {
        id: toBeDeletedOnDatabase.id,
        name: null,
        content: null,
        createdAt: toBeDeletedOnDatabase.createdAt,
        updatedAt: '2000-01-01T05:00:00.000Z',
        savedOnDBAt: toBeDeletedOnDatabase.savedOnDBAt,
        isDeleted: true
      }
      // Modified.
      const conflictedAsBeingModifiedOnDevice: DocumentFromDevice = {
        ...toBeConflicted,
        updatedAt: '2000-01-01T06:00:00.000Z',
      }
      const conflictedAsBeingModifiedOnDatabase: Document = {
        ...toBeConflicted,
        updatedAt: '2000-01-01T07:00:00.000Z',
        savedOnDBAt: '2000-01-01T07:00:01.000Z',
      }
      // Added.
      const addedOnDevice: DocumentFromDevice = {
        id: uuidv4(),
        name: 'Added on device',
        content: 'This is added on device.',
        createdAt: '2000-01-01T08:00:00.000Z',
        updatedAt: '2000-01-01T08:00:00.000Z',
        savedOnDBAt: null,
        isDeleted: false
      }
      const addedOnDatabase: Document = {
        id: uuidv4(),
        name: 'Added on database',
        content: 'This is added on database.',
        createdAt: '2000-01-01T09:00:00.000Z',
        updatedAt: '2000-01-01T09:00:00.000Z',
        savedOnDBAt: '2000-01-01T09:00:01.000Z',
        isDeleted: false
      }
      // Prepare database.
      // Synched before this time.
      await dbClient.query(sql`
        INSERT INTO documents (
          id,
          user_id,
          name,
          content,
          created_at,
          updated_at,
          saved_on_db_at,
          is_deleted
        )
        VALUES (
          ${alreadySynched.id},
          ${mainUser.id},
          ${alreadySynched.name},
          ${alreadySynched.content},
          ${fromISOStringToDatetimeString(alreadySynched.createdAt)},
          ${fromISOStringToDatetimeString(alreadySynched.updatedAt)},
          ${fromISOStringToDatetimeString(alreadySynched.savedOnDBAt)},
          false
        );
      `)
      await dbClient.query(sql`
        INSERT INTO documents (
          id,
          user_id,
          name,
          content,
          created_at,
          updated_at,
          saved_on_db_at,
          is_deleted
        )
        VALUES (
          ${toBeDeletedOnDevice.id},
          ${mainUser.id},
          ${toBeDeletedOnDevice.name},
          ${toBeDeletedOnDevice.content},
          ${fromISOStringToDatetimeString(toBeDeletedOnDevice.createdAt)},
          ${fromISOStringToDatetimeString(toBeDeletedOnDevice.updatedAt)},
          ${fromISOStringToDatetimeString(toBeDeletedOnDevice.savedOnDBAt)},
          false
        );
      `)
      // Deleted.
      await dbClient.query(sql`
        INSERT INTO documents (
          id,
          user_id,
          name,
          content,
          created_at,
          updated_at,
          saved_on_db_at,
          is_deleted
        )
        VALUES (
          ${deletedOnDatabase.id},
          ${mainUser.id},
          ${deletedOnDatabase.name},
          ${deletedOnDatabase.content},
          ${fromISOStringToDatetimeString(deletedOnDatabase.createdAt)},
          ${fromISOStringToDatetimeString(deletedOnDatabase.updatedAt)},
          ${fromISOStringToDatetimeString(deletedOnDatabase.savedOnDBAt)},
          true
        );
      `)
      // Modified.
      await dbClient.query(sql`
        INSERT INTO documents (
          id,
          user_id,
          name,
          content,
          created_at,
          updated_at,
          saved_on_db_at,
          is_deleted
        )
        VALUES (
          ${conflictedAsBeingModifiedOnDatabase.id},
          ${mainUser.id},
          ${conflictedAsBeingModifiedOnDatabase.name},
          ${conflictedAsBeingModifiedOnDatabase.content},
          ${fromISOStringToDatetimeString(conflictedAsBeingModifiedOnDatabase.createdAt)},
          ${fromISOStringToDatetimeString(conflictedAsBeingModifiedOnDatabase.updatedAt)},
          ${fromISOStringToDatetimeString(conflictedAsBeingModifiedOnDatabase.savedOnDBAt)},
          false
        );
      `)
      // Added.
      await dbClient.query(sql`
        INSERT INTO documents (
          id,
          user_id,
          name,
          content,
          created_at,
          updated_at,
          saved_on_db_at,
          is_deleted
        )
        VALUES (
          ${addedOnDatabase.id},
          ${mainUser.id},
          ${addedOnDatabase.name},
          ${addedOnDatabase.content},
          ${fromISOStringToDatetimeString(addedOnDatabase.createdAt)},
          ${fromISOStringToDatetimeString(addedOnDatabase.updatedAt)},
          ${fromISOStringToDatetimeString(addedOnDatabase.savedOnDBAt)},
          false
        );
      `)
      const documentsRequest: DocumentsUpdateRequest = {
        updates: [
          addedOnDevice,
          deletedOnDevice,
          conflictedAsBeingModifiedOnDevice,
        ]
      }
      const copiedOnConflictDuplication: DocumentFromDevice = {
        ...conflictedAsBeingModifiedOnDevice,
        id: expect.any(String),
        name: `[Conflicted]: ${conflictedAsBeingModifiedOnDevice.name}`,
        updatedAt: expect.stringMatching(regIsISODateString),
      }
      const documentsUploadResponse: DocumentsUpdateResponse = {
        allDocuments: [
          {
            ...copiedOnConflictDuplication,
            savedOnDBAt: expect.stringMatching(regIsISODateString)
          },
          {
            ...addedOnDatabase,
            savedOnDBAt: expect.stringMatching(regIsISODateString)
          },
          {
            ...addedOnDevice,
            savedOnDBAt: expect.stringMatching(regIsISODateString)
          },
          {
            ...conflictedAsBeingModifiedOnDatabase,
            savedOnDBAt: expect.stringMatching(regIsISODateString)
          },
          {
            ...deletedOnDatabase,
            savedOnDBAt: expect.stringMatching(regIsISODateString)
          },
          {
            ...deletedOnDevice,
            savedOnDBAt: expect.stringMatching(regIsISODateString)
          },
          {
            ...alreadySynched,
            savedOnDBAt: expect.stringMatching(regIsISODateString)
          },
        ],
        savedOnDBAt: expect.stringMatching(regIsISODateString),
        updatedIdsAsUnavailable: [],
        duplicatedIdsAsConflicted: [
          {
            original: conflictedAsBeingModifiedOnDevice.id,
            duplicated: copiedOnConflictDuplication.id
          }
        ]
      }
      // TESTED REQUEST
      const res = await request(apiApp)
        .post(API_PATHS.DOCUMENTS.path)
        .set('Cookie', mainUserSetCookieHeaders)
        .send(documentsRequest)
      expect(res.status).toBe(200)
      expect(res.body).toEqual(documentsUploadResponse)
      await assertSession(res, true, mainUser.email)
      expect(copiedOnConflictDuplication.id).not.toBe(conflictedAsBeingModifiedOnDevice.id)
      expect(conflictedAsBeingModifiedOnDevice.updatedAt < copiedOnConflictDuplication.updatedAt).toBe(true)
      const onDatabase = (await dbClient.query(sql`
        SELECT
          *,
          UNIX_TIMESTAMP(created_at) AS created_at,
          UNIX_TIMESTAMP(updated_at) AS updated_at,
          UNIX_TIMESTAMP(saved_on_db_at) AS saved_on_db_at
        FROM documents
        WHERE user_id = ${mainUser.id}
        ORDER BY updated_at DESC, saved_on_db_at DESC, created_at DESC;
      `)) as DocumentFromDB[]
      expect(onDatabase.map(document => normalizeDocument(document))).toEqual(documentsUploadResponse.allDocuments)
      await sleep(100)
      const message: DocumentUpdatedWsMessage = {savedOnDBAt: expect.stringMatching(regIsISODateString)}
      expect(mainUserCallback).toBeCalledWith(message)
      expect(otherUserCallback).not.toBeCalled()
    } catch (e) {
      throw e
    } finally {
      mainUserSocket.close()
      otherUserSocket.close()
    }
  })

  test('returns old update from other device', async () => {
    const newerDocument: DocumentFromDevice = {
      id: uuidv4(),
      name: 'Newer document',
      content: 'This is newer document.',
      createdAt: '2000-01-01T02:00:00.000Z',
      updatedAt: '2000-01-01T02:00:00.000Z',
      savedOnDBAt: null,
      isDeleted: false
    }
    const olderDocument: DocumentFromDevice = {
      id: uuidv4(),
      name: 'Older document',
      content: 'This is older document.',
      createdAt: '2000-01-01T01:00:00.000Z',
      updatedAt: '2000-01-01T01:00:00.000Z',
      savedOnDBAt: null,
      isDeleted: false
    }

    const documentsRequest1FromDeviceA: DocumentsUpdateRequest = {
      updates: [
        newerDocument,
      ]
    }
    const documentsUploadResponse1ForDeviceA: DocumentsUpdateResponse = {
      allDocuments: [
        {
          ...newerDocument,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
      ],
      savedOnDBAt: expect.stringMatching(regIsISODateString),
      updatedIdsAsUnavailable: [],
      duplicatedIdsAsConflicted: []
    }

    const mainUserResLogin = await request(apiApp)
      .post(API_PATHS.AUTH.LOGIN.path)
      .send({ email: mainUser.email, password: mainUser.password })
    const mainUserSetCookieHeaders: string[] = mainUserResLogin.headers['set-cookie']

    const res1ForDeviceA = await request(apiApp)
      .post(API_PATHS.DOCUMENTS.path)
      .set('Cookie', mainUserSetCookieHeaders)
      .send(documentsRequest1FromDeviceA)
    expect(res1ForDeviceA.body).toEqual(documentsUploadResponse1ForDeviceA)
    const res1ForDeviceASetCookieHeaders: string[] = res1ForDeviceA.headers['set-cookie']

    const documentsRequestFromDeviceB: DocumentsUpdateRequest = {
      updates: [
        olderDocument,
      ]
    }
    const documentsUploadResponseForDeviceB: DocumentsUpdateResponse = {
      allDocuments: [
        {
          ...newerDocument,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
        {
          ...olderDocument,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
      ],
      savedOnDBAt: expect.stringMatching(regIsISODateString),
      updatedIdsAsUnavailable: [],
      duplicatedIdsAsConflicted: []
    }
    const resForDeviceB = await request(apiApp)
      .post(API_PATHS.DOCUMENTS.path)
      .set('Cookie', res1ForDeviceASetCookieHeaders)
      .send(documentsRequestFromDeviceB)
    expect(resForDeviceB.body).toEqual(documentsUploadResponseForDeviceB)
    const resForDeviceBSetCookieHeaders: string[] = resForDeviceB.headers['set-cookie']

    const documentsRequest2FromDeviceA: DocumentsUpdateRequest = {
      updates: []
    }
    const documentsUploadResponse2ForDeviceA: DocumentsUpdateResponse = {
      allDocuments: [
        {
          ...newerDocument,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
        {
          ...olderDocument,
          savedOnDBAt: expect.stringMatching(regIsISODateString)
        },
      ],
      savedOnDBAt: expect.stringMatching(regIsISODateString),
      updatedIdsAsUnavailable: [],
      duplicatedIdsAsConflicted: []
    }
    const res2ForDeviceA = await request(apiApp)
      .post(API_PATHS.DOCUMENTS.path)
      .set('Cookie', resForDeviceBSetCookieHeaders)
      .send(documentsRequest2FromDeviceA)
    expect(res2ForDeviceA.body).toEqual(documentsUploadResponse2ForDeviceA)
  })
})
