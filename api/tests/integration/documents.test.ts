import bcrypt from 'bcrypt'
import jwt from 'jsonwebtoken'
import request from 'supertest'
import { v4 as uuidv4 } from 'uuid'
import apiApp, { wsServer } from '../../src/servers/api'
import getConnectionPool, { ConnectionPool, sql } from '../../src/db/database'
import { API_PATHS, AUTH_TOKEN_KEY, DOCUMENT_CONTENT_LENGTH_LIMIT, DOCUMENT_NAME_LENGTH_LIMIT, DOCUMENT_UPDATED_WS_EVENT } from "../../src/constants"
import { Document, DocumentFromDB, DocumentsUpdateRequest, DocumentsUpdateResponse } from '../../src/models/document'
import { JWT_SECRET_KEY, WS_PORT } from '../../src/getEnvs'
import { fromISOStringToTimeStamp, normalize } from '../../src/routes/documents'
import { io } from 'socket.io-client'

let db: ConnectionPool
beforeAll(() => {
  db = getConnectionPool()
  return addUsers()
})
afterAll(() => {
  wsServer.close()
  return db.dispose()
})

type User = { id: number, email: string, password: string, authToken: string }
let mainUser: User
let otherUser: User
const addUsers = async () => {
  mainUser = await generateUser('user1@email.com', 'user1Password')
  otherUser = await generateUser('user2@email.com', 'user2Password')
}
async function generateUser(email: string, password: string): Promise<User> {
  const id = await addUserToDabase(email, password)
  const authToken = jwt.sign(
    {is: 'AuthToken', id, email},
    JWT_SECRET_KEY
  )
  return { id, email, password, authToken }
}
/** @return {number} ID generated by database */
async function addUserToDabase(email: string, password: string): Promise<number> {
  const salt = await bcrypt.genSalt(10)
  const hashedUser1Password = await bcrypt.hash(password, salt)
  await db.query(sql`
    INSERT INTO users (
      email,
      password,
      is_activated
    )
    VALUES (
      ${email},
      ${hashedUser1Password},
      true
    );
  `)
  return (await db.query(sql`
    SELECT id
      FROM users
      WHERE email = ${email};
  `))[0].id
}

beforeEach(() => {
  // Initialize documents table.
  return db.query(sql`
    DELETE FROM documents;
  `)
})
afterEach(() => {
})

// TODO: Update main script to use @database/mysql?

describe(`POST ${API_PATHS.DOCUMENTS.path}`, () => {

  // apiAuthMiddleware tests(check if it guards invalid requests)

  test('returns 401 if no auth token provided', async () => {
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [],
      requestUpdatesOnDBAfter: null
    }
    // TESTED REQUEST
    const res = await request(apiApp)
      .post(API_PATHS.DOCUMENTS.path)
      .send(documentsRequest)
    expect(res.status).toBe(401)
    expect(res.body.message).toBe('Access denied. Request does not have valid token.')
  })

  test('returns 401 without updating any documents and emitting no event if no auth token is not valid', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const newDocumentFromDevice: Document = {
      id: uuidv4(),
      name: 'New Document from Device',
      content: 'This is a new document from the device.',
      createdAt: '2000-01-02T00:00:00.000Z',
      updatedAt: '2000-01-02T00:00:00.000Z',
      isDeleted: false,
    }
    const newDocumentFromDatabase: Document = {
      id: uuidv4(),
      name: 'New Document from Database',
      content: 'This is a new document from the database.',
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      isDeleted: false,
    }
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        newDocumentFromDevice,
      ],
      requestUpdatesOnDBAfter: null
    }
    // Add new document from other device beforehand.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        is_deleted
      )
      VALUES (
        ${newDocumentFromDatabase.id},
        ${mainUser.id},
        ${newDocumentFromDatabase.name},
        ${newDocumentFromDatabase.content},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.createdAt)},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.updatedAt)},
        ${newDocumentFromDatabase.isDeleted}
      );
    `)
    // TESTED REQUEST
    const res = await request(apiApp)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: `${mainUser.authToken}1`})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(401)
    expect(res.body.message).toBe('Access denied. Request does not have valid token.')
    // Check database.
    const result = await db.query(sql`
      SELECT id
        FROM documents
        WHERE user_id = ${mainUser.id};
    `)
    expect(result).toEqual([
      {id: newDocumentFromDatabase.id},
    ])
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).not.toBeCalled()
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  test('returns 401 without updating any documents and emitting no event if no auth token is not encoded with right secret', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const newDocumentFromDevice: Document = {
      id: uuidv4(),
      name: 'New Document from Device',
      content: 'This is a new document from the device.',
      createdAt: '2000-01-02T00:00:00.000Z',
      updatedAt: '2000-01-02T00:00:00.000Z',
      isDeleted: false,
    }
    const newDocumentFromDatabase: Document = {
      id: uuidv4(),
      name: 'New Document from Database',
      content: 'This is a new document from the database.',
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      isDeleted: false,
    }
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        newDocumentFromDevice,
      ],
      requestUpdatesOnDBAfter: null
    }
    // Add new document from other device beforehand.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        is_deleted
      )
      VALUES (
        ${newDocumentFromDatabase.id},
        ${mainUser.id},
        ${newDocumentFromDatabase.name},
        ${newDocumentFromDatabase.content},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.createdAt)},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.updatedAt)},
        ${newDocumentFromDatabase.isDeleted}
      );
    `)
    const invalidMainUserAuthToken = jwt.sign(
      {is: 'AuthToken', id: mainUser.id, email: mainUser.email},
      `${JWT_SECRET_KEY}1`
    )
    // TESTED REQUEST
    const res = await request(apiApp)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: invalidMainUserAuthToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(401)
    expect(res.body.message).toBe('Access denied. Request does not have valid token.')
    // Check database.
    const result = await db.query(sql`
      SELECT id
        FROM documents
        WHERE user_id = ${mainUser.id};
    `)
    expect(result).toEqual([
      {id: newDocumentFromDatabase.id},
    ])
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).not.toBeCalled()
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  test('returns 401 without updating any documents and emitting no event if no auth token is not authToken', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const newDocumentFromDevice: Document = {
      id: uuidv4(),
      name: 'New Document from Device',
      content: 'This is a new document from the device.',
      createdAt: '2000-01-02T00:00:00.000Z',
      updatedAt: '2000-01-02T00:00:00.000Z',
      isDeleted: false,
    }
    const newDocumentFromDatabase: Document = {
      id: uuidv4(),
      name: 'New Document from Database',
      content: 'This is a new document from the database.',
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      isDeleted: false,
    }
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        newDocumentFromDevice,
      ],
      requestUpdatesOnDBAfter: null
    }
    // Add new document from other device beforehand.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        is_deleted
      )
      VALUES (
        ${newDocumentFromDatabase.id},
        ${mainUser.id},
        ${newDocumentFromDatabase.name},
        ${newDocumentFromDatabase.content},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.createdAt)},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.updatedAt)},
        ${newDocumentFromDatabase.isDeleted}
      );
    `)
    const mainUserNotAuthToken = jwt.sign(
      {is: 'SignupToken', id: mainUser.id, email: mainUser.email},
      JWT_SECRET_KEY
    )
    // TESTED REQUEST
    const res = await request(apiApp)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUserNotAuthToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(401)
    expect(res.body.message).toBe('Access denied. Request does not have valid token.')
    // Check database.
    const result = await db.query(sql`
      SELECT id
        FROM documents
        WHERE user_id = ${mainUser.id};
    `)
    expect(result).toEqual([
      {id: newDocumentFromDatabase.id},
    ])
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).not.toBeCalled()
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })


  // documentsRequestValidatorMiddleware tests(check if it guards invalid requests)

  test('return 400 without updating any documents and emitting no event if request body is not valid DocumentsRequest', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const invalidNewDocumentFromDevice: Document = {
      id: uuidv4(),
      name: 'New Document from Device',
      content: 'This is a new document from the device.',
      createdAt: '2000-01-02T00:00:00.000Z',
      updatedAt: '2000-01-02T00:00:00.000',
      isDeleted: false,
    }
    const newDocumentFromDatabase: Document = {
      id: uuidv4(),
      name: 'New Document from Database',
      content: 'This is a new document from the database.',
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      isDeleted: false,
    }
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        invalidNewDocumentFromDevice,
      ],
      requestUpdatesOnDBAfter: null
    }
    // Add new document from other device beforehand.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        is_deleted
      )
      VALUES (
        ${newDocumentFromDatabase.id},
        ${mainUser.id},
        ${newDocumentFromDatabase.name},
        ${newDocumentFromDatabase.content},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.createdAt)},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.updatedAt)},
        ${newDocumentFromDatabase.isDeleted}
      );
    `)
    // TESTED REQUEST
    const res = await request(apiApp)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(400)
    expect(res.body.message).toBe("\"updated[0].updatedAt\" with value \"2000-01-02T00:00:00.000\" fails to match the required pattern: /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/")
    // Check database.
    const result = await db.query(sql`
      SELECT id
        FROM documents
        WHERE user_id = ${mainUser.id};
    `)
    expect(result).toEqual([
      {id: newDocumentFromDatabase.id},
    ])
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).not.toBeCalled()
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  test('not update database with too long name and not send the id back', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const newDocumentWithTooLongNameFromDevice: Document = {
      id: uuidv4(),
      name: 'a'.repeat(DOCUMENT_NAME_LENGTH_LIMIT + 1),
      content: 'This is a new document from the device.',
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      isDeleted: false,
    }
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        newDocumentWithTooLongNameFromDevice,
      ],
      requestUpdatesOnDBAfter: null
    }
    // TESTED REQUEST
    const res = await request(apiApp)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(400)
    expect(res.body.message).toBe("\"updated[0].name\" length must be less than or equal to 50 characters long")
    // Check database.
    const result = await db.query(sql`
      SELECT id
        FROM documents
        WHERE user_id = ${mainUser.id};
    `)
    expect(result).toEqual([])
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).not.toBeCalled()
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  test('update database with not too long name and sends the id back', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const newDocumentWithNotTooLongNameFromDevice: Document = {
      id: uuidv4(),
      name: 'a'.repeat(DOCUMENT_NAME_LENGTH_LIMIT),
      content: 'This is a new document from the device.',
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      isDeleted: false,
    }
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        newDocumentWithNotTooLongNameFromDevice,
      ],
      requestUpdatesOnDBAfter: null
    }
    const documentsUploadResponse: DocumentsUpdateResponse = {
      updatesFromDB: [],
      updateSuccessIds: [
        newDocumentWithNotTooLongNameFromDevice.id,
      ]
    }
    // TESTED REQUEST
    const res = await request(apiApp)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(200)
    expect(res.body).toEqual(documentsUploadResponse)
    // Check database.
    const result = await db.query(sql`
      SELECT id
        FROM documents
        WHERE user_id = ${mainUser.id};
    `)
    expect(result).toEqual([
      {id: newDocumentWithNotTooLongNameFromDevice.id},
    ])
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).toBeCalledWith(newDocumentWithNotTooLongNameFromDevice.updatedAt)
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  test('not update database with too long content and not send the id back', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const newDocumentWithTooLongContentFromDevice: Document = {
      id: uuidv4(),
      name: 'New Document from Device',
      content: 'a'.repeat(DOCUMENT_CONTENT_LENGTH_LIMIT + 1),
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      isDeleted: false,
    }
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        newDocumentWithTooLongContentFromDevice,
      ],
      requestUpdatesOnDBAfter: null
    }
    // TESTED REQUEST
    const res = await request(apiApp)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(400)
    expect(res.body.message).toBe("\"updated[0].content\" length must be less than or equal to 20000 characters long")
    // Check database.
    const result = await db.query(sql`
      SELECT id
        FROM documents
        WHERE user_id = ${mainUser.id};
    `)
    expect(result).toEqual([])
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).not.toBeCalled()
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  test('updates database with not too long content and sends the id back', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const newDocumentWithNotTooLongContentFromDevice: Document = {
      id: uuidv4(),
      name: 'New Document from Device',
      content: 'a'.repeat(DOCUMENT_CONTENT_LENGTH_LIMIT),
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      isDeleted: false,
    }
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        newDocumentWithNotTooLongContentFromDevice,
      ],
      requestUpdatesOnDBAfter: null
    }
    const documentsUploadResponse: DocumentsUpdateResponse = {
      updatesFromDB: [],
      updateSuccessIds: [
        newDocumentWithNotTooLongContentFromDevice.id,
      ]
    }
    // TESTED REQUEST
    const res = await request(apiApp)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(200)
    expect(res.body).toEqual(documentsUploadResponse)
    // Check database.
    const result = await db.query(sql`
      SELECT id
        FROM documents
        WHERE user_id = ${mainUser.id};
    `)
    expect(result).toEqual([
      {id: newDocumentWithNotTooLongContentFromDevice.id},
    ])
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).toBeCalledWith(newDocumentWithNotTooLongContentFromDevice.updatedAt)
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  test("inserts on database with new id and returns id change back to device if new document id from device is already registered as the user's another document with different creation time", async () => {
    console.log('TODO: Write test.')
  })

  test("inserts on database with new id and returns id change back to device if new document id from device is already registered as another user's document", async () => {
    console.log('TODO: Write test.')
  })


  // documentsRouter tests

  test('updates database with updated documents from device and send back updated document id and emit event', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const newDocumentFromDevice: Document = {
      id: uuidv4(),
      name: 'New Document from Device',
      content: 'This is a new document from the device.',
      createdAt: '2000-01-02T00:00:00.000Z',
      updatedAt: '2000-01-02T00:00:00.000Z',
      isDeleted: false,
    }
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        newDocumentFromDevice,
      ],
      requestUpdatesOnDBAfter: null
    }
    const documentsUploadResponse: DocumentsUpdateResponse = {
      updatesFromDB: [],
      updateSuccessIds: [
        newDocumentFromDevice.id,
      ]
    }
    // TESTED REQUEST
    const res = await request(apiApp)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(200)
    expect(res.body).toEqual(documentsUploadResponse)
    // Check database.
    const result = await db.query(sql`
      SELECT id
        FROM documents
        WHERE user_id = ${mainUser.id};
    `)
    expect(result).toEqual([
      {id: newDocumentFromDevice.id},
    ])
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).toBeCalledWith(expect.stringMatching(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/))
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  test('returns all documents on database if latestUpdatedDocumentFromDBAt is not provided', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const oldDocumentFromDatabase: Document = {
      id: uuidv4(),
      name: 'Old Document from Database',
      content: 'This is an old document from the database.',
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      isDeleted: false,
    }
    const newDocumentFromDatabase: Document = {
      id: uuidv4(),
      name: 'New Document from Database',
      content: 'This is a new document from the database.',
      createdAt: '2000-01-02T00:00:00.000Z',
      updatedAt: '2000-01-02T00:00:00.000Z',
      isDeleted: false,
    }
    // Add documents from other device beforehand.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        is_deleted
      )
      VALUES (
        ${oldDocumentFromDatabase.id},
        ${mainUser.id},
        ${oldDocumentFromDatabase.name},
        ${oldDocumentFromDatabase.content},
        ${fromISOStringToTimeStamp(oldDocumentFromDatabase.createdAt)},
        ${fromISOStringToTimeStamp(oldDocumentFromDatabase.updatedAt)},
        ${oldDocumentFromDatabase.isDeleted}
      );
    `)
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        is_deleted
      )
      VALUES (
        ${newDocumentFromDatabase.id},
        ${mainUser.id},
        ${newDocumentFromDatabase.name},
        ${newDocumentFromDatabase.content},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.createdAt)},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.updatedAt)},
        ${newDocumentFromDatabase.isDeleted}
      );
    `)
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [],
      requestUpdatesOnDBAfter: null
    }
    const documentsUploadResponse: DocumentsUpdateResponse = {
      updatesFromDB: [
        newDocumentFromDatabase,
        oldDocumentFromDatabase,
      ],
      updateSuccessIds: []
    }
    // TESTED REQUEST
    const res = await request(apiApp)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(200)
    expect(res.body).toEqual(documentsUploadResponse)
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).not.toBeCalled()
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  test('returns documents on database updated after the time if latestUpdatedDocumentFromDBAt is provided', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const oldDocumentFromDatabase: Document = {
      id: uuidv4(),
      name: 'Old Document from Database',
      content: 'This is an old document from the database.',
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      isDeleted: false,
    }
    const newDocumentFromDatabase: Document = {
      id: uuidv4(),
      name: 'New Document from Database',
      content: 'This is a new document from the database.',
      createdAt: '2000-01-02T00:00:00.000Z',
      updatedAt: '2000-01-02T00:00:00.000Z',
      isDeleted: false,
    }
    // Add documents from other device beforehand.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        is_deleted
      )
      VALUES (
        ${oldDocumentFromDatabase.id},
        ${mainUser.id},
        ${oldDocumentFromDatabase.name},
        ${oldDocumentFromDatabase.content},
        ${fromISOStringToTimeStamp(oldDocumentFromDatabase.createdAt)},
        ${fromISOStringToTimeStamp(oldDocumentFromDatabase.updatedAt)},
        ${oldDocumentFromDatabase.isDeleted}
      );
    `)
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        is_deleted
      )
      VALUES (
        ${newDocumentFromDatabase.id},
        ${mainUser.id},
        ${newDocumentFromDatabase.name},
        ${newDocumentFromDatabase.content},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.createdAt)},
        ${fromISOStringToTimeStamp(newDocumentFromDatabase.updatedAt)},
        ${newDocumentFromDatabase.isDeleted}
      );
    `)
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [],
      requestUpdatesOnDBAfter: oldDocumentFromDatabase.updatedAt
    }
    const documentsUploadResponse: DocumentsUpdateResponse = {
      updatesFromDB: [
        newDocumentFromDatabase,
      ],
      updateSuccessIds: []
    }
    // TESTED REQUEST
    const res = await request(apiApp)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(200)
    expect(res.body).toEqual(documentsUploadResponse)
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).not.toBeCalled()
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  test('Updates document on database.', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const oldDocumentFromDatabase: Document = {
      id: uuidv4(),
      name: 'Old Document from Database',
      content: 'This is an old document from the database.',
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      isDeleted: false,
    }
    const newDocumentFromDevice: Document = {
      id: oldDocumentFromDatabase.id,
      name: 'New Document from Database',
      content: 'This is a new document from the database.',
      createdAt: oldDocumentFromDatabase.createdAt,
      updatedAt: '2000-01-02T00:00:00.000Z',
      isDeleted: false,
    }
    // Add documents from other device beforehand.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        is_deleted
      )
      VALUES (
        ${oldDocumentFromDatabase.id},
        ${mainUser.id},
        ${oldDocumentFromDatabase.name},
        ${oldDocumentFromDatabase.content},
        ${fromISOStringToTimeStamp(oldDocumentFromDatabase.createdAt)},
        ${fromISOStringToTimeStamp(oldDocumentFromDatabase.updatedAt)},
        ${oldDocumentFromDatabase.isDeleted}
      );
    `)
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        newDocumentFromDevice,
      ],
      requestUpdatesOnDBAfter: oldDocumentFromDatabase.updatedAt
    }
    const documentsUploadResponse: DocumentsUpdateResponse = {
      updatesFromDB: [],
      updateSuccessIds: [
        newDocumentFromDevice.id,
      ]
    }
    // TESTED REQUEST
    const res = await request(apiApp)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(200)
    expect(res.body).toEqual(documentsUploadResponse)
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).toBeCalledWith(newDocumentFromDevice.updatedAt)
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  test('inserts conflicted document with new id on database and returns it back to device with updated on database if document of an id has update both from device and database and emit update to websocket', async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    const originalDocument: Document = {
      id: uuidv4(),
      name: 'Original Document',
      content: 'This is an original document.',
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      isDeleted: false,
    }
    const updatedOnDatabase: Document = {
      ...originalDocument,
      updatedAt: '2000-01-02T00:00:00.000Z'
    }
    const updatedOnDevice: Document = {
      ...originalDocument,
      updatedAt: '2000-01-03T00:00:00.000Z'
    }
    // Add documents from other device beforehand.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        is_deleted
      )
      VALUES (
        ${updatedOnDatabase.id},
        ${mainUser.id},
        ${updatedOnDatabase.name},
        ${updatedOnDatabase.content},
        ${fromISOStringToTimeStamp(updatedOnDatabase.createdAt)},
        ${fromISOStringToTimeStamp(updatedOnDatabase.updatedAt)},
        ${updatedOnDatabase.isDeleted}
      );
    `)
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        updatedOnDevice,
      ],
      requestUpdatesOnDBAfter: originalDocument.updatedAt
    }
    const copiedOnConflictDuplication: Document = {
      ...updatedOnDevice,
      id: expect.any(String),
      name: `[Conflicted]: ${updatedOnDevice.name}`,
      updatedAt: expect.stringMatching(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/),
    }
    const documentsUploadResponse: DocumentsUpdateResponse = {
      updatesFromDB: [
        copiedOnConflictDuplication,
        updatedOnDatabase,
      ],
      updateSuccessIds: []
    }
    // TESTED REQUEST
    const res = await request(apiApp)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest)
    // EXPECTED RESPONSE
    expect(res.status).toBe(200)
    expect(res.body).toEqual(documentsUploadResponse)
    // Check no event on websocket.
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).toBeCalledWith(expect.stringMatching(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/))
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })

  // Test every case at once.
  test("returns updated documents and emit latest updated time to user's websocket with modified document from device and other device being updated to database and conflicted document being duplicated", async () => {
    const mainUserCallback = jest.fn()
    const mainUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: mainUser.authToken}})
    mainUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, mainUserCallback)
    mainUserSocket.connect()
    const otherUserCallback = jest.fn()
    const otherUserSocket = io(`ws://localhost:${WS_PORT}`, {autoConnect: false, auth: {token: otherUser.authToken}})
    otherUserSocket.on(DOCUMENT_UPDATED_WS_EVENT, otherUserCallback)
    otherUserSocket.connect()
    // Synched before this time.
    const alreadySynched: Document = {
      id: uuidv4(),
      name: 'Already synced on both device and database',
      content: 'This is already synced on both device and database.',
      createdAt: '2000-01-01T00:00:00.000Z',
      updatedAt: '2000-01-01T00:00:00.000Z',
      isDeleted: false
    }
    const toBeDeletedOnDevice: Document = {
      id: uuidv4(),
      name: 'To be deleted on device',
      content: 'This is to be deleted on device.',
      createdAt: '2000-01-01T01:00:00.000Z',
      updatedAt: '2000-01-01T01:00:00.000Z',
      isDeleted: false
    }
    const toBeDeletedOnDatabase: Document = {
      id: uuidv4(),
      name: 'To be deleted on database',
      content: 'This is to be deleted on database.',
      createdAt: '2000-01-01T02:00:00.000Z',
      updatedAt: '2000-01-01T02:00:00.000Z',
      isDeleted: false
    }
    const toBeConflicted: Document = {
      id: uuidv4(),
      name: 'To be conflicted',
      content: 'This is to be conflicted.',
      createdAt: '2000-01-01T03:00:00.000Z',
      updatedAt: '2000-01-01T03:00:00.000Z',
      isDeleted: false
    }
    // Deleted.
    const deletedOnDevice: Document = {
      id: toBeDeletedOnDevice.id,
      name: null,
      content: null,
      createdAt: toBeDeletedOnDevice.createdAt,
      updatedAt: '2000-01-01T04:00:00.000Z',
      isDeleted: true
    }
    const deletedOnDatabase: Document = {
      id: toBeDeletedOnDatabase.id,
      name: null,
      content: null,
      createdAt: toBeDeletedOnDatabase.createdAt,
      updatedAt: '2000-01-01T05:00:00.000Z',
      isDeleted: true
    }
    // Modified.
    const conflictedAsBeingModifiedOnDevice: Document = {
      ...toBeConflicted,
      updatedAt: '2000-01-01T06:00:00.000Z'
    }
    const conflictedAsBeingModifiedOnDatabase: Document = {
      ...toBeConflicted,
      updatedAt: '2000-01-01T07:00:00.000Z'
    }
    // Added.
    const addedOnDevice: Document = {
      id: uuidv4(),
      name: 'Added on device',
      content: 'This is added on device.',
      createdAt: '2000-01-01T08:00:00.000Z',
      updatedAt: '2000-01-01T08:00:00.000Z',
      isDeleted: false
    }
    const addedOnDatabase: Document = {
      id: uuidv4(),
      name: 'Added on database',
      content: 'This is added on database.',
      createdAt: '2000-01-01T09:00:00.000Z',
      updatedAt: '2000-01-01T09:00:00.000Z',
      isDeleted: false
    }
    // Prepare database.
    // Synched before this time.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        is_deleted
      )
      VALUES (
        ${alreadySynched.id},
        ${mainUser.id},
        ${alreadySynched.name},
        ${alreadySynched.content},
        ${fromISOStringToTimeStamp(alreadySynched.createdAt)},
        ${fromISOStringToTimeStamp(alreadySynched.updatedAt)},
        false
      );
    `)
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        is_deleted
      )
      VALUES (
        ${toBeDeletedOnDevice.id},
        ${mainUser.id},
        ${toBeDeletedOnDevice.name},
        ${toBeDeletedOnDevice.content},
        ${fromISOStringToTimeStamp(toBeDeletedOnDevice.createdAt)},
        ${fromISOStringToTimeStamp(toBeDeletedOnDevice.updatedAt)},
        false
      );
    `)
    // Deleted.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        is_deleted
      )
      VALUES (
        ${deletedOnDatabase.id},
        ${mainUser.id},
        ${deletedOnDatabase.name},
        ${deletedOnDatabase.content},
        ${fromISOStringToTimeStamp(deletedOnDatabase.createdAt)},
        ${fromISOStringToTimeStamp(deletedOnDatabase.updatedAt)},
        true
      );
    `)
    // Modified.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        is_deleted
      )
      VALUES (
        ${conflictedAsBeingModifiedOnDatabase.id},
        ${mainUser.id},
        ${conflictedAsBeingModifiedOnDatabase.name},
        ${conflictedAsBeingModifiedOnDatabase.content},
        ${fromISOStringToTimeStamp(conflictedAsBeingModifiedOnDatabase.createdAt)},
        ${fromISOStringToTimeStamp(conflictedAsBeingModifiedOnDatabase.updatedAt)},
        false
      );
    `)
    // Added.
    await db.query(sql`
      INSERT INTO documents (
        id,
        user_id,
        name,
        content,
        created_at,
        updated_at,
        is_deleted
      )
      VALUES (
        ${addedOnDatabase.id},
        ${mainUser.id},
        ${addedOnDatabase.name},
        ${addedOnDatabase.content},
        ${fromISOStringToTimeStamp(addedOnDatabase.createdAt)},
        ${fromISOStringToTimeStamp(addedOnDatabase.updatedAt)},
        false
      );
    `)
    const documentsRequest: DocumentsUpdateRequest = {
      updates: [
        addedOnDevice,
        deletedOnDevice,
        conflictedAsBeingModifiedOnDevice,
      ],
      requestUpdatesOnDBAfter: toBeConflicted.updatedAt
    }
    const copiedOnConflictDuplication: Document = {
      ...conflictedAsBeingModifiedOnDevice,
      id: expect.any(String),
      name: `[Conflicted]: ${conflictedAsBeingModifiedOnDevice.name}`,
      updatedAt: expect.stringMatching(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/),
    }
    const documentsUploadResponse: DocumentsUpdateResponse = {
      updatesFromDB: [
        copiedOnConflictDuplication,
        addedOnDatabase,
        conflictedAsBeingModifiedOnDatabase,
        deletedOnDatabase,
      ],
      updateSuccessIds: [
        addedOnDevice.id,
        deletedOnDevice.id,
      ]
    }
    // TESTED REQUEST
    const res = await request(apiApp)
      .post(API_PATHS.DOCUMENTS.path)
      .set({[AUTH_TOKEN_KEY]: mainUser.authToken})
      .send(documentsRequest)
    expect(res.status).toBe(200)
    expect(res.body).toEqual(documentsUploadResponse)
    expect(copiedOnConflictDuplication.id).not.toBe(conflictedAsBeingModifiedOnDevice.id)
    expect(conflictedAsBeingModifiedOnDevice.updatedAt < copiedOnConflictDuplication.updatedAt).toBe(true)
    const onDatabase = (await db.query(sql`
      SELECT *
        FROM documents
        WHERE user_id = ${mainUser.id}
        ORDER BY updated_at DESC, created_at DESC;
    `)) as DocumentFromDB[]
    expect(onDatabase.map(document => normalize(document))).toEqual([
      copiedOnConflictDuplication,
      addedOnDatabase,
      addedOnDevice,
      conflictedAsBeingModifiedOnDatabase,
      deletedOnDatabase,
      deletedOnDevice,
      alreadySynched,
    ])
    await new Promise<void>(resolve => setTimeout(resolve, 100))
    expect(mainUserCallback).toBeCalledWith(expect.stringMatching(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/))
    mainUserSocket.close()
    expect(otherUserCallback).not.toBeCalled()
    otherUserSocket.close()
  })
})
